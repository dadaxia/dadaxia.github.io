<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Make more time]]></title>
    <url>%2F2018%2F05%2F10%2F2018-05-10-MakeMoreTime%2F</url>
    <content type="text"><![CDATA[今天听到一首歌，触动心弦。 Time Money is not evil by itself Its just paper with perceived value to obtain other things we value in other ways If not money - what is evil you may ask? Evil is the unquenchable Obsessive and moral bending desire for more Evil is the bottomless Soulless and obsessive-compulsive pursuit of some pot of gold At the end of some rainbow which doesn’t exist Evil is having a price tag for your heart and soul in exchange for financial success at any cost Evil is trying to buy happiness Again and again Util all of those fake Short lived mirages of emotions are gone Make more time I’m not saying you can’t be financially successful Your soul is screaming for you to answer your true calling You can change today if you redefine what success is to you You can transform your damaged relationships and build new ones You can forgive yourself and others who’ve hurt you You can become a leader by mentoring with others who you aspire to be like You can re-balance your priorities in life You can become the best parent possible at any age - even 86 But don’t wait until then… You will always be able to make more money But you cannot make more time 翻译成中文就是： Time 钱本不邪恶 钱只是商品流通的交换介质，只是一张纸 那你会问，什么是邪恶？ 邪恶是上瘾的到的扭曲的欲望 是强迫自己无休止地觊觎 那些并不存在的梦幻 邪恶是你不惜一切代价获取经济利益的价格标签 是贪得无厌，索取幸福 直到那些虚幻的蜃景消逝 让时间更有意义 我并不是说你不能在经济上取得成功 我是说有一个伟大的生活目标会超越经济方面的成功 你的灵魂在尖叫着等你最真切的回应 如果你重新定义成功，你可以改变自己的现状 你可能改善并重新建立你的人际关系 你可能原谅自己和伤害过你的人 在你仰慕的人的指导下你也可能成为一个领导者 你可以重新调整生活的重心 你可以治愈你的婚姻并重建真爱 你在任何年纪都可能成为最好的父母，甚至在86岁 但千万别等到那时 你将来可能会赚很多钱 却得不到更多时间]]></content>
      <categories>
        <category>我的人生</category>
      </categories>
      <tags>
        <tag>人生观</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Next Theme这是我将之前jekyll上的博客转移到这里的第一篇自动生成的博客。使用Hexo在本地搭建博客，Next是一个很棒的简洁的主题。Next的下载地址为Next。Next官方使用文档Next Document。 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java字符串]]></title>
    <url>%2F2018%2F04%2F03%2F2018-04-03-java%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[不可变StringString对象是不可变的。查看JDK文档你就会发现，String类中每一个看起来会修改String值的方法，实际都是重新创建了一个全新的String对象，以包含修改后的字符串内容。而最初的String对象则丝毫未动。 123456789101112public class Immutable &#123; public static String upcase(String s) &#123; return s.toUpperCase(); &#125; public static void main(String[] args) &#123; String q = &quot;howdy&quot;; System.out.println(q); String qq = upcase(q); System.out.println(qq); System.out.println(q); &#125;&#125; 当把q传递给upcase()方法时，实际传递的是引用的一个拷贝。其实，每当把String对象作为方法的参数时，都会复制一份引用，而该引用所指的对象其实一直待在单一的物理位置上，从未动过。回到upcase()的定义，传入其中的引用有了名字s，只有upcase()运行的时候，局部引用s才存在。一旦upcase()运行结束，s就消失了。当然了，upcase()的返回值，其实只是最终结果的引用。这足以说明，upcase()返回的引用已经指向了一个新的对象，而原本的q则还在原地。 参考《Thinking in java》 String\StringBuilder\StringBuffer我们要记住三者的特征： String字符串常量 StringBuffer字符串变量（线程安全） StringBuilder字符串变量（线程不安全） 定义 查看API会发现，String、StringBuilder、StringBuffer都实现了CharSequence接口，内部都是用一个char数组实现，虽然它们都与字符串相关，但是其处理机制不同。 String：是不可改变的量，也就是创建后不能再修改了。 StringBuffer：是一个可变字符串序列，它与String一样，在内存中保存的都是一个有序的字符串序列（char类型的数组），不同点事StringBuffer对象的值是可以改变的。 StringBuilder：与StringBuffer类基本相同，都是可变字符串序列，不同点是StringBuffer是线程安全的，StringBuilder是线程不安全的。 使用场景 使用String类的场景：在字符串不经常变化的场景中可以使用String类，例如常量的声明、少量的变量运算。 使用StringBuffer类的场景：在频繁进行字符串运算（如拼接、替换、删除等），并且运行在多线程环境中，则可以考虑使用StringBuffer，例如XML解析、HTTP参数解析和封装。 使用StringBuilder类的场景：在频繁进行字符串运算（如拼接、替换、删除等），并且运行在单线程环境中，则可以考虑使用StringBuilder，如SQL语句的拼装、JSON封装等。 分析在性能方面，由于String类的操作是产生新的String对象，而StringBuilder和StringBuffer只是一个字符数组的扩容而已，所以String类的操作要远慢于StringBuffer和StringBuilder。简要的说，String类和StringBuffer类型的主要性能区别其实在于String是不可变的对象，因此在每次对String类型进行改变的时候其实等于生成了一个新的String对象，然后将指针指向新的String对象。所以经常改变内容的字符串不要使用String，因为每次都产生新对象会对性能产生影响，特别当内存中无引用对象多了以后，JVM的GC就会开始工作，那性能一定会是非常慢的。而如果使用了StringBuffer类则结果就不一样了，每次结果都是对StringBuffer对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用StringBuffer，特别是字符串经常改变的情况下。而在某些特别情况下，String对象的字符串拼接其实是被JVM解释成了StringBuffer对象的拼接，所以这时候String对象的速度并不会比StringBuffer对象慢，而特别是以下的字符串生成中，String效率是远要StringBuffer快的：12String s1 = &quot;This is only a &quot;+&quot;simple&quot;+&quot; test&quot;;StringBuffer sb = new StringBuffer(&quot;This ia only a&quot;).append(&quot; test&quot;); 你会很快惊讶的发现，生成String s1对象的速度简直太快了，而这个时候StringBuffer的数据居然一点不占优势。其实这是JVM的一个把戏，在JVM里，这个123String s1 = &quot;This is only a &quot;+&quot;simple&quot;+&quot; test&quot;;``` 其实就是： String s1 = “This is only a simple test”;12所以当然不需要太多的时间了。但大家要注意的是，如果你的字符串是来自另外的String对象的话，速度就没那么快了，譬如： String s2 = “This is only a”;String s3 = “simple”;String s4 = “test”;String s1 = s2+s3+s4;123456这时候JVM会规规矩矩的按照原来的方式去做。 **又及：** #### 关于equal和== ==用于比较两个对象的时候，是来check是否两个引用指向了同一块内存。 String obj1 = new String(“xyz”);String obj2 = new String(“xyz”); if(obj1 == obj2){ System.out.println(“obj1 == obj2 is TRUE”);}else{ System.out.println(“obj1 == obj2 is FALSE”);}12这是输出的就是false String obj1 = new String(“xyz”);String obj2 = obj1;if(obj1 == obj2){ System.out.println(“obj1 == obj2 is TRUE”);}else{ System.out.println(“obj1 == obj2 is FALSE”);}1这个输出的是true，一个特殊的情况： String s1 = “xyz”;String s2 = “xyz”;System.out.println(s1 == s2);123456789输出的是true。这是因为： 字符串缓冲池：程序在运行的时候会创建一个字符串缓冲池。 当使用String s1 = &quot;xyz&quot;;这样的表达式是创建字符串的时候（非new这种方式），程序首先会在这个String缓冲池中寻找相同值的对象，在String str1 = &quot;xyz&quot;;中，s1先被放到了池中，所以s2在被创建的时候，程序找到了具有相同值的str1，并将s2引用指向s1所指向的对象。 #### equals()equals()是Object的方法，默认情况下它与==一样，比较的是地址。 但是当equals()被重载之后，根据设计，equal会比较对象的value。而这个是java希望有的功能。 String类就重写了这个方法： String obj1 = new String(“xyz”);String obj2 = new String(“xyz”);if(obj1 == obj2){ System.out.println(“obj1 == obj2 is TRUE”);}else{ System.out.println(“obj1 == obj2 is FALSE”);}123结果返回true。 总的说，String有个特点：如果程序中有多个String对象，都包含相同的字符串序列，那么这些String对象都映射到同一块内存区域，所以两次new String(&quot;hello&quot;),生成两个实例，虽然是相互独立的，但是对它们使用hashCode()应该是同样的结果。Note：字符串数组并非这样，只有String是这样。即hashCode对于String，是基于其内容的。 public class StringHashCode { public static void main(String[] args){ //输出结果相同 String[] hellos = “Hello Hello”.split(“ “); System.out.println(“”+hellos[0].hashCode()); System.out.println(“”+hellos[1].hashCode()); //输出结果相同 String a = new String(“hello”); String b = new String(“hello”); System.out.println(“”+a.hashCode()); System.out.println(“”+b.hashCode()); }} 1234567891011121314151617181920212223#### 结论String类是final类，不可以继承。对String类型最好的重用方式是组合而不是继承。 String有length()方法，数组有length属性。 String s = new String(&quot;xyz&quot;);创建了几个对象？ 两个对象，一个静态存储区&quot;xyz&quot;,一个用new在堆上创建的对象。 String和StringBuffer、StringBuilder区别？ 在大部分情况下StringBuffer &gt; String Java.lang.StringBuffer是线程安全的可变字符序列。一个类似于String的字符串缓冲区，但是不能够修改。虽然在任意时间点上它都包含某种特定的可变字符序列，但通过某些方法调用可以修改序列的长度和内容。在程序中可将字符串缓存区安全地用于多线程。而且在必要时可以对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。 StringBuffer上的主要操作时append和insert方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效的将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append方法始终将这些字符添加到缓冲区的末端；而insert方法则在指定的点添加字符。例如，如果 z 引用一个当前内容是 “start”的字符串缓冲区对象，则此方法调用 z.append(“le”) 会使字符串缓冲区包含 “startle”( 累加); 而 z.insert(4, “le”) 将更改字符串缓冲区，使之包含 “starlet”。 在大部分情况下 StringBuilder &gt; StringBuffer java.lang.StringBuilder 一个可变的字符序列是 JAVA 5.0 新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步，所以使用场景是单线程。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。**如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。**两者的使用方法基本相同。 StringBuffer 和 StringBuilder 都是继承于 AbstractStringBuilder, 底层的逻辑（比如append）都包含在这个类中。 public AbstractStringBuilder append(String str) { if (str == null) str = “null”; int len = str.length(); ensureCapacityInternal(count + len);//查看使用空间满足，不满足扩展空间 str.getChars(0, len, value, count);//getChars就是利用native的array copy,性能高效 count += len; return this; } ` StringBuffer 底层也是 char[], 数组初始化的时候就定下了大小, 如果不断的 append 肯定有超过数组大小的时候，我们是不是定义一个超大容量的数组，太浪费空间了。就像 ArrayList 的实现，采用动态扩展，每次 append 首先检查容量，容量不够就先扩展，然后复制原数组的内容到扩展以后的数组中。 参考：http://www.importnew.com/16881.html]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java异常]]></title>
    <url>%2F2018%2F04%2F02%2F2018-04-02-java%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[简介程序运行时，发生的不被期望的事件，它阻止了程序的预期正常运行，这就是异常。异常发生时如何处理？java提供了异常处理机制。java异常处理机制能让程序在异常发生时，按照代码的预先设定的异常处理逻辑，正对性的处理异常，让程序尽最大可能恢复正常并继续执行，且保持代码的清晰。java中的异常可以是函数中的语句执行时引发的，也可以是程序员通过throw语句手动抛出的，只要在java程序中产生了异常，就会用一个对应类型的异常对象来封装异常，JRE就会试图寻找异常处理程序来处理异常。Throwable类是java异常类型的顶层父类，一个对象只有是Throwable类的（直接或间接）实例，它才是一个异常对象，才能被异常处理机制识别。JDK中内建了一些常用的异常类，我们也可以自定义异常。 java异常的分类和类结构java标准库内建了一些通用的异常，这些类以Throwable为顶层父类。Throwable又派生出Error类和Exception类。错误：Error类以及它的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error很少出现。因此程序员应该关注Exception为父类的分支下的各种异常类。异常：Exception以及它的子类，代表程序运行时发送的各种不期望发生的事件。可以被java异常处理机制使用，是异常处理的核心。 总体上我们根据javac对异常的处理要求，将异常分为两类。 非检查异常非检查异常(unchecked exception)Error和RuntimeException以及它们的子类。javac在编译时，不会提示和发现这样的异常，不要求在程序中处理这类异常。所以如果愿意，我们可以编写代码处理（使用try…catch…finally）这样的异常，也可以不处理。对于这些异常，我们应该修正代码，而不是通过异常处理机制处理。这样的异常发生的原因多半是代码写的有问题。如除0异常AirthmeticException，错误的强制类型转换异常，数组索引越界ArrayIndexOutOfBoundsException，使用了空对象NullPointException等等。 检查异常检查异常(checked exception)除了Error和RunTimeException的其它异常，javac强制要求程序员为这样的异常做预备处理工作（使用try…catch…finally）。在方法中要么用try-catch捕获它并处理，要么使用throws字句声明抛出它，否则编译不会通过。这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，而程序员无法干预程用户如何使用他编写的程序，于是程序员就应该为这样的异常时刻准备着。如SQLException，IOException，ClassNotFoundException等。 需要明确的是：检查和非检查是对于javac来说的，这样就很好理解和区分了。 初识异常12345678910111213141516171819202122package com.example;import java. util .Scanner ;public class AllDemo&#123; public static void main (String [] args ) &#123; System . out. println( &quot;----欢迎使用命令行除法计算器----&quot; ) ; CMDCalculate (); &#125; public static void CMDCalculate () &#123; Scanner scan = new Scanner ( System. in ); int num1 = scan .nextInt () ; int num2 = scan .nextInt () ; int result = devide (num1 , num2 ) ; System . out. println( &quot;result:&quot; + result) ; scan .close () ; &#125; public static int devide (int num1, int num2 )&#123; return num1 / num2 ; &#125;&#125; 123456789101112131415161718Output:----欢迎使用命令行除法计算器----0Exception in thread &quot;main&quot; java.lang.ArithmeticException : / by zero at com.example.AllDemo.devide( AllDemo.java:30 ) at com.example.AllDemo.CMDCalculate( AllDemo.java:22 ) at com.example.AllDemo.main( AllDemo.java:12 )----欢迎使用命令行除法计算器----rException in thread &quot;main&quot; java.util.InputMismatchException at java.util.Scanner.throwFor( Scanner.java:864 ) at java.util.Scanner.next( Scanner.java:1485 ) at java.util.Scanner.nextInt( Scanner.java:2117 ) at java.util.Scanner.nextInt( Scanner.java:2076 ) at com.example.AllDemo.CMDCalculate( AllDemo.java:20 ) at com.example.AllDemo.main( AllDemo.java:12 ) 异常是在执行某个函数时引发的，而函数又是层级调用，形成调用栈的，因为，只要一个函数发生了异常，那么它所有的caller都会被异常影响。当这些被影响的函数以异常信息输出时，就形成了异常追踪栈。异常最先发生的地方叫做异常抛出点。 从上面的例子可以看出，当devide函数发生异常时，devide函数将抛出ArithmeticException异常，因此调用它的CMDCaculate函数也无法正常完成，因此也发送异常，而CMDCaculate的caller——main因为CMDCaculate抛出异常，也会发生异常，这样一直向调用栈的栈底回溯。这种行为叫异常的冒泡，异常的冒泡是为了在当前发生异常的函数或这个函数的caller找到最近的异常处理程序。由于这个例子没有任何的异常处理机制，因此最终由main抛给JRE，导致程序终止。上面的代码不适用异常处理机制，也可以顺利编译，因为这两个异常都是非检查异常。但是下面的例子就必须使用异常处理机制，因为异常时检查异常。代码中我使用throws声明异常，让函数的调用者去处理可能发生的异常。但是为什么只throws了IOException呢？因为FileNotFoundException是IOException的子类，在处理范围内。 1234567891011121314public void testException() throws IOException&#123; //FileInputStream的构造函数会抛出FileNotFoundException FileInputStream fileIn = new FileInputStream(&quot;E:\\a.txt&quot;); int word; //read方法会抛出IOException while((word = fileIn.read())!=-1) &#123; System.out.print((char)word); &#125; //close方法会抛出IOException fileIn.clos&#125; 异常处理的基本语法在编写代代码处理异常时，对于检查异常，有2中不同的处理方式：使用try…catch…finally语句块处理它。或者，在函数签名中使用throws声明交给函数调用者caller去解决。 try…catch…finally语句块123456789101112131415161718try&#123; //try块中放可能发生异常的代码。 //如果执行完try且不发生异常，则接着执行finally块和finally后面的代码（如果有的话） //如果发生异常，则尝试去匹配catch块&#125;catch(SQLException SQLException)&#123; //每个catch块用于捕获并处理一个特定的异常，或者这个异常的子类。java7中可以将多个异常声明在一个catch中。 //catch后面的括号定义异常类型和异常参数，如果异常与之匹配且是最先匹配到的，则虚拟机将使用这个catch块来处理异常。 //在catch块中可以使用这个快的异常参数来获取异常的相关信息。异常参数是这个catch块中的局部变量，其它块不能访问。 //如果当前try块中发生的异常在后续的所有catch中都没有捕获到，则先去执行finally，然后到这个函数的外部caller中去匹配异常处理器。 //如果try中没有发生异常，则所有的catch块将被忽略。&#125;catch(Exception exception)&#123; //...&#125;finally&#123; //finally块通常是可选的。 //无论异常是否发生，异常是否匹配被处理，finally都会被执行。 //一个try至少要有一个catch块，否则，至少要有一个finally块。但是finally不能用来处理异常，finally不会捕获异常。 //finally主要做一些清理工作，如流的关闭，数据库连接的关闭等。&#125; 需要注意的地方： try块中局部变量和catch块中的局部变量（包括异常变量），以及finally中的局部变量，它们之间不可共享使用。 每一个catch块用来处理一个异常。异常匹配是按照catch块的顺序从上往下寻找的，只有第一个匹配的catch会得到执行。匹配时，不仅运行精确匹配，也支持父类匹配，因此，如果同一个try块下的有多个catch异常类型有父子关系，应该讲子类异常放在前面，父类异常放在后面，这样保证每一个catch块存在都有意义。 java中，异常处理的任务就是将执行控制流从异常发生的地方转移到能够处理这种异常的地方去。也就是说：当一个函数的某个条件发生异常时，这条语句的后面的语句不会再执行，它失去了焦点。执行流跳转到最近的匹配的异常处理catch代码块区执行，异常处理完后，执行流会接着“处理了这个异常的catch代码块”后面接着执行。有的编程语言当异常被处理后，控制流会恢复到异常抛出点接着执行，这种策略叫做：resumption model of exception handing（恢复式异常处理模式）而java则是让执行流恢复到处理了异常的catch块后接着执行，这种策略叫做：termination model of exception handing（终结式异常处理模式） 123456789101112public static void mian(String[] args)&#123; try&#123; foo(); &#125;catch(ArithmeticException ae)&#123; System.out.println(&quot;处理异常&quot;); &#125;&#125;public static void foo()&#123; int a = 5/0;//异常抛出点 System.out.println(&quot;为什么还不给我涨工资！！！！&quot;);//不会执行&#125; throws函数声明throws声明：如果一个方法内部的代码会抛出异常检查（checked exception），而方法自己又没有完全处理掉，则javac保证你必须在方法的签名上使用关键字throws声明这些可能抛出的异常，否则编译不通过。throws是另一种处理异常的方式，它不同于try…catch…finally，throws仅仅是将函数中可能出现的异常向调用者声明，而自己不做具体处理。采取这种异常处理机制的原因可能是：方法本身不知道如何处理这样的异常，或者说让调用者处理更好，调用者需要为可能发生的异常负责。 123public void foo() throws ExceptionType1,ExceptionType2,ExceptionType3&#123; //foo内部可以抛出ExceptionType1,ExceptionType2,ExceptionType3类的异常，或者它们的子类的异常对象。&#125; finally块finally块不管异常是否发生，只要对应的try执行了，则它一定执行。只有一种方法让finally块不执行:System.exit()。因此finally块通常用来做资源释放操作：关闭文件，关闭数据库连接等等。良好的变成习惯是：在try块中打开资源，在finally块中清理释放这些资源。需要注意的地方： finally块没有处理异常的能力，处理异常的只能是catch块。 在同一try…catch…finally块中，如果try中抛出异常，且有匹配的catch块，则先执行catch块，再执行finally块。如果没有匹配的catch块，则先执行finally块，然后去外面的调用者中寻找合适的catch块。3.在同一try…catch…finally块中，try发生异常，且匹配的catch块中处理异常时也抛出异常，那么后面的finally也会执行：先执行finally块，然后去外围调用者中寻找合适的catch块。这是正常的情况，但是也有特例。关于finally很多复杂的问题，在本文最后统一介绍。 throw异常抛出语句throw exceptionObject程序员也可以通过throw语句手动显式地抛出一个异常。throw语句的后面必须是一个异常对象。throw语句必须写在函数中，执行throw语句的地方就是一个异常抛出点，它和由JRE自动形成的异常抛出点没有任何差别。 12345public void save(User user)&#123; if(user == null)&#123; throw new IllegalArgumentException(&quot;User对象为空&quot;); &#125;&#125; 异常的链化在一些大型的、模块化的软件开发中，一旦一个地方发生异常，则如骨牌效应，将导致一连串的异常。假设B模块完成自己的逻辑需要调用A模块的方法，如果A模块发生异常，则B也不能完成而发生异常，但是在B抛出异常时，会将A的异常信息掩盖掉，这将是的异常的根源信息丢失。异常的链化可以将多个模块的异常串联起来，使得异常信息不会丢失。异常链化以一个异常对象为参数构造新的异常对象。新的异常对象将包含先前异常的信息。这项技术主要是异常类的一个带Throwable参数的函数来实现的。这个当做参数的异常，我们叫它根源异常（cause）。查看Throwable类源码，可以发现里面有一个Throwable字段的cause，就是它保存了构造时传递的根源异常参数。这种设计和链表的结点类设计如出一辙，因此形成链也是自然的了。 123456789101112131415public class Throwable implements Serializable&#123; private Throwable cause = this; public Throwable(String message, Throwable cause)&#123; fillInStackTrace(); detailMessage = message; this.cause = cause; &#125; public Throwable(Throwable cause)&#123; fillInStackTrace(); detailMessage = (cause==null ? null : cause.toString()); this.cause cause; &#125;&#125; 下面是一个例子，演示了异常的链化：从命令行输入2个int，将它们相加，输出。输入的数不是int，则导致getInputNumbers异常，从而导致add函数异常，则可以在add函数中抛出一个链化的异常。 1234567891011121314151617181920212223242526public static void main(String[] args)&#123; System.out.println(&quot;请输入2个加数&quot;); int result; try&#123; result = add(); System.out.println(&quot;结果：&quot;+result); &#125;catch(Exception exception)&#123; exception.printStack(); &#125;&#125;//获取输入的2个整数返回private static List&lt;Integer&gt; getInputNumbers()&#123; List&lt;Integer&gt; nums = new ArrayList&lt;Integer&gt;(); Scanner scan = new Scanner(System.in); try&#123; int num1 = scan.nextInt(); int num2 = scan.nextInt(); nums.add(new Integer(num1)); nums.add(new Integer(num2)); &#125;catch(InputMismatchException immExp)&#123; throw new Exception(&quot;计算失败&quot;,immExp);//链化：以一个异常对象为参数构造新的异常对象。 &#125; return result;&#125; 123456789101112131415Output:请输入2个加数r 1java.lang.Exception: 计算失败 at practise.ExceptionTest.add(ExceptionTest.java:53) at practise.ExceptionTest.main(ExceptionTest.java:18)Caused by: java.util.InputMismatchException at java.util.Scanner.throwFor(Scanner.java:864) at java.util.Scanner.next(Scanner.java:1485) at java.util.Scanner.nextInt(Scanner.java:2117) at java.util.Scanner.nextInt(Scanner.java:2076) at practise.ExceptionTest.getInputNumbers(ExceptionTest.java:30) at practise.ExceptionTest.add(ExceptionTest.java:48) ... 1 more 自定义异常如果要自定义异常，则扩展Exception类即可，因此这样的自定义异常都属于检查异常（checked exception）。如果要自定义非检查异常，则扩展RuntimeException。按照国际惯例，自定义的异常应该总是包含如下的构造函数： 一个无参构造器 一个带有String参数的构造函数，并传递给父类的构造函数 一个带有String参数和Throwable参数，并都传递给父类构函数 一个带有Throwable参数的构造函数，并传递给父类的构造函数 下面是IOException类的完整源代码，可以借鉴： 12345678910111213141516public class IOException extends Exception&#123; static final long seriaVersionUID = 7818375828146090155L; public IOException()&#123; super(); &#125; public IOException(String message)&#123; super(message); &#125; public IOException(String message,Throwable cause)&#123; super(message,cause); &#125; public IOException(Throwable cause)&#123; super(cause); &#125;&#125; 异常注意的事项 当子类重写父类的带有throws声明的函数时，其throws声明的异常必须在父类异常的可控范围内——用于处理父类的throws方法的异常处理器，必须也用适于子类的这个带throws方法。这是为了支持多态。例如，父类方法throws的是2个异常，子类就不能throws3个及以上的异常。父类throws IOException，子类就必须throws IOException或者IOException的子类。下面的例子会说明： 1234567891011121314151617181920212223242526272829303132class Father &#123; public void start() throws IOException&#123; throw new IOException(); &#125;&#125;class Son extends Father &#123; public void start() throws Exception&#123; throw new SQLException(); &#125;&#125;//*******************************************假设上面的代码是允许的，实际是错误的***************************************class Test&#123; public static void main(String[] args)&#123; Father[] objs = new Father[2]; objs[0] = new Father(); objs[1] = new Son(); for(Father obj:objs)&#123; //因为Son类抛出的实质是SQLException，而IOException无法处理它。 //那么这里的try...catch就不能处理Son中的异常。 //多态就不能实现了。 try&#123; obj.start(); &#125;catch(IOException e)&#123; //处理IOException &#125; &#125; &#125;&#125; java中的异常是线程独立的，本线程的问题应该由本线程自己解决，不能委托到外部，也不会直接影响到其它线程的执行。即本线程的异常如果没有被处理，只能回导致本线程的运行中断，不会造成其它线程中断。 finally块和return首先一个不容易理解的事实：在try块中即使有return，break，continue等改变执行流的语句，finally也会执行。 1234567891011121314151617public static void main(String[] args)&#123; int re = bar(); System.out.println(re);&#125;private static int bar() &#123; try&#123; return 5; &#125; finally&#123; System.out.println(&quot;finally&quot;); &#125;&#125;/*输出：finally5*/ 很多人在面临这个问题时，总是在归纳执行的顺序和规律，不过我还是觉得很难理解。我自己总结了一个方法，用如下的GIF图说明： 也就是说：try…catch…finally中的return只要能够执行，就都执行了，它们共同向一个内存地址（假设地址是0x80）写入返回值，后执行的将覆盖先执行的数据，而真正被调用者取的返回值就是最后一次写入的。那么，按照这个思想，下面的这个例子也就不难理解了。 finally中的return会覆盖try…catch中的返回值 123456789101112131415161718192021222324252627282930313233public static void main(String[] args) &#123; int result; result = foo(); System.out.println(result); /////////2 result = bar(); System.out.println(result); /////////2 &#125; @SuppressWarnings(&quot;finally&quot;) public static int foo() &#123; trz&#123; int a = 5 / 0; &#125; catch (Exception e)&#123; return 1; &#125; finally&#123; return 2; &#125; &#125; @SuppressWarnings(&quot;finally&quot;) public static int bar() &#123; try &#123; return 1; &#125;finally &#123; return 2; &#125; &#125; finally中的return会抑制（消灭）前面try或者catch块中的异常 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class TestException&#123; public static void main(String[] args) &#123; int result; try&#123; result = foo(); System.out.println(result); //输出100 &#125; catch (Exception e)&#123; System.out.println(e.getMessage()); //没有捕获到异常 &#125; try&#123; result = bar(); System.out.println(result); //输出100 &#125; catch (Exception e)&#123; System.out.println(e.getMessage()); //没有捕获到异常 &#125; &#125; //catch中的异常被抑制 @SuppressWarnings(&quot;finally&quot;) public static int foo() throws Exception &#123; try &#123; int a = 5/0; return 1; &#125;catch(ArithmeticException amExp) &#123; throw new Exception(&quot;我将被忽略，因为下面的finally中使用了return&quot;); &#125;finally &#123; return 100; &#125; &#125; //try中的异常被抑制 @SuppressWarnings(&quot;finally&quot;) public static int bar() throws Exception &#123; try &#123; int a = 5/0; return 1; &#125;finally &#123; return 100; &#125; &#125;&#125; finally中的异常会覆盖（消灭）try或者catch中的异常 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class TestException&#123; public static void main(String[] args) &#123; int result; try&#123; result = foo(); &#125; catch (Exception e)&#123; System.out.println(e.getMessage()); //输出：我是finaly中的Exception &#125; try&#123; result = bar(); &#125; catch (Exception e)&#123; System.out.println(e.getMessage()); //输出：我是finaly中的Exception &#125; &#125; //catch中的异常被抑制 @SuppressWarnings(&quot;finally&quot;) public static int foo() throws Exception &#123; try &#123; int a = 5/0; return 1; &#125;catch(ArithmeticException amExp) &#123; throw new Exception(&quot;我将被忽略，因为下面的finally中抛出了新的异常&quot;); &#125;finally &#123; throw new Exception(&quot;我是finaly中的Exception&quot;); &#125; &#125; //try中的异常被抑制 @SuppressWarnings(&quot;finally&quot;) public static int bar() throws Exception &#123; try &#123; int a = 5/0; return 1; &#125;finally &#123; throw new Exception(&quot;我是finaly中的Exception&quot;); &#125; &#125;&#125; 上面的例子都异于常人的编码思维，因此建议： 不在finally中使用return 不要在finally中抛出异常 减轻finally的任务，不要在finally中做一些其它的事情，finally块仅仅用来释放资源是最合适的 尽量将所有的return都写在函数的最后面，而不是在try…catch…fianlly中。 转自：https://www.cnblogs.com/lulipro/p/7504267.html]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合之迭代器]]></title>
    <url>%2F2018%2F03%2F29%2F2018-03-29-Java%E9%9B%86%E5%90%88%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[迭代器是一个对象，它的工作是遍历并选择序列中的对象，而客户端程序员不必知道或关心该序列的底层结构。此外迭代器通常被称为轻量级对象：创建它的代价小。因此经常会见到对迭代器有些奇怪的限制，例如，Java的Iterator只能单向移动，这个Iterator只能用来： 使用方法iterator()要求容器返回一个Iterator。Iterator将准备好返回序列的第一个元素。 使用next()获得序列中下一个元素。 使用hasNext()检查序列中是否还有元素。 使用remove()将迭代器返回的元素删除。 如果只是向前遍历List，并不打算修改List对象本身，那么用foreach语法会显得更加简洁。Iterator还可以移除由next()产生的最后一个元素，这意味着在调用remove()之前必须先调用next()。 ListIteratorListIterator是一个更加强大的Iterator的子类集，它只能用于各种List类的访问。尽管Iterator只能向前移动，但是ListIterator可以双向移动。它还可以产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引，并且可以用set()方法替换它访问的最后一个元素。可以通过调用listIterator()方法产生一个指向List开始处的ListIterator，并且还可以通过调用listIterator(n)方法创建一个一开始就指向列表索引为n的元素处的ListIterator。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合之容器的打印]]></title>
    <url>%2F2018%2F03%2F29%2F2018-03-29-Java%E9%9B%86%E5%90%88%E4%B9%8B%E5%AE%B9%E5%99%A8%E6%89%93%E5%8D%B0%2F</url>
    <content type="text"><![CDATA[必须使用Arrays.toString()来产生数组的可打印表示，但是打印容器（集合）无序任何帮助。示例： 123456789101112131415161718192021222324252627public class PrintingContainers &#123; static Collection fill(Collection&lt;String&gt; collection) &#123; collection.add(&quot;rat&quot;); collection.add(&quot;cat&quot;); collection.add(&quot;dog&quot;); collection.add(&quot;dog&quot;); return collection; &#125; static Map fill(Map&lt;String,String&gt; map) &#123; map.put(&quot;rat&quot;,&quot;Fuzzy&quot;); map.put(&quot;cat&quot;,&quot;Rags&quot;); map.put(&quot;dog&quot;,&quot;Bosco&quot;); map.put(&quot;dog&quot;,&quot;Spot&quot;); return map; &#125; public static void main(String[] args) &#123; System.out.println(fill(new ArrayList&lt;String&gt;())); System.out.println(fill(new LinkedList&lt;String&gt;())); System.out.println(fill(new HashSet&lt;String&gt;())); System.out.println(fill(new TreeSet&lt;String&gt;())); System.out.println(fill(new LinkedHashSet&lt;String&gt;())); System.out.println(fill(new HashMap&lt;String,String&gt;())); System.out.println(fill(new TreeMap&lt;String,String&gt;())); System.out.println(fill(new LinkedHashMap&lt;String,String&gt;())); &#125;&#125; 123456789Output: [rat, cat, dog, dog] [rat, cat, dog, dog] [rat, cat, dog] [cat, dog, rat] [rat, cat, dog] &#123;rat=Fuzzy, cat=Rags, dog=Spot&#125; &#123;cat=Rags, dog=Spot, rat=Fuzzy&#125; &#123;rat=Fuzzy, cat=Rags, dog=Spot&#125; 从示例可以看出： List以特定的顺序保存一组元素 Set元素不能重复 Queue只允许在容器一端插入对象，并从另一端移除对象（本例没有展示） Map在每个槽中保存了两个对象，即键和值，而且键不能重复。与HashSet一样，HashMap也提供了最快的查找技术，也没有按照任何明显的顺序来保存其元素。TreeMap按照比较结果的升序保存键，而LinkedHashMap则按照插入顺序保存键，同时还保留了HashMap的查询速度。 查看输出会发现，默认的打印行为（适用容器的toString()方法)即可生成可读性很好的结果。Collection打印出来的内容用方括号括住，每个元素由逗号分隔。Map则用大括号括住，键与值由等号联系。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合之List]]></title>
    <url>%2F2018%2F03%2F29%2F2018-03-29-Java%E9%9B%86%E5%90%88%E4%B9%8BList%2F</url>
    <content type="text"><![CDATA[List承诺可以将元素维护在特定的序列中。List在Collection的基础上添加了大量的方法，使得可以在List的中间插入和移除元素。由两种类型的List： ArrayList：长于随机访问元素，但在List中间插入和移除元素时代价较大。 LinkedList：它通过代价较低的在List中间进行插入和删除操作，提供了优化的顺序访问。LinkedList在随机访问方面相对较慢，但是它的特性集较ArrayList大。 LinkedListLinkedList也想ArrayList一样实现了基本的List接口，但是它执行某些操作（在List的中间插入和移除）时比ArrayList更高效，但是在随机访问操作方面却要逊色一些。 Stack“栈”通常是指“后进先出”（LIFO）的容器。有时栈也被称为叠加栈，因为最后“压入”栈的元素，第一个“弹出”栈。LinkedList具有能够直接实现栈的所有功能的方法，因此可以直接将LinkedList作为栈使用。不过，有时一个真正的“栈”更能把事情搞清楚： 123456789101112131415161718public class Stack&lt;T&gt; &#123; private LinkedList&lt;T&gt; storage = new LinkedList&lt;T&gt;(); public void push(T v) &#123; storage.addFirst(v); &#125; public T peek() &#123; return storage.getFirst(); &#125; public T pop() &#123; return storage.removeFirst(); &#125; public boolean empty() &#123; return storage.isEmpty(); &#125; public String toString() &#123; return storage.toString(); &#125;&#125; 这里通过使用泛型，引入了在栈的类定义中最简单的可行示例。类名之后的告诉编译器这将是一个参数化类型，而其中的类型参数，即在类被使用时将会被实际类型替换的参数，就是T。Java中也有Stack类的定义，在java.util中。 SetSet不保存重复的元素。查找是Set中最重要的操作，HashSet专门对快速查找做了优化。 Queue队列是一个典型的先进先出（FIFO）的容器。即从容器的一端放入事物，从另一端取出，并且事物放入容器的顺序与取出的顺序相同。队列常被当做一种可靠的将对象从程序的某个区域传输到另一个区域的的途径。队列在并发编程中特别重要，因为它们可以安全地将对象从一个任务传输给另一个任务。 PriorityQueue先进先出描述了最典型的队列规则。队列规则是指在给定一组队列中的元素的情况下，确定下一个弹出队列的元素的规则。先进先出声明的是下一个元素应该是等待时间最长的元素。优先队列声明下一个弹出元素是最需要的元素（具有最高的优先级）。例如，在飞机场，当飞机临近起飞时，这架飞机的乘客可以在办理登记手续时排到队头。如果构建了一个消息系统，某些消息比其它消息更重要，因而应该更快的地得到处理，那么它们何时得到处理就与它们何时到达无关。PriorityQueue添加到JavaSE5中，是为了提供这种行为的一种自动实现。当你在PriorityQueue上调用offer()方法来插入一个对象时，这个对象会在队列中被排序。默认的排序将使用对象在队列中的自然顺序，但是你可以通过提供自己的Comparator来修改这个顺序。PriorityQueue可以确保当你调用peek()、poll()和remove()方法时，获取的元素将是队列中优先级最高的元素。让PriorityQueue与Integer、String和Character这样的内置类型一起工作易如反掌。在下面的示例中，第一个值集与前一个示例中的随机值相同，因此你可以看到他们从PriorityQueue中弹出的顺序与前一个示例不同： 1234567891011121314151617181920public class QueueDemo &#123; public static void printQ(Queue&lt;?&gt; queue) &#123; while(queue.peek() != null) &#123; System.out.print(queue.remove()+&quot; &quot;); &#125; System.out.println(); &#125; public static void main(String[] args) &#123; Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); Random random = new Random(47); for(int i=0; i&lt;10; i++) &#123; queue.offer(random.nextInt(i+10)); &#125; printQ(queue); Queue&lt;Character&gt; qc = new LinkedList&lt;Character&gt;(); for(char c : &quot;Brontosaurus&quot;.toCharArray()) qc.offer(c); printQ(qc); &#125;&#125; 123OutPut: 8 1 1 1 5 14 3 1 0 1 B r o n t o s a u r u s 1234567891011121314151617181920212223242526272829303132public class PriorityQueueDemo &#123; public static void main(String[] args) &#123; PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;Integer&gt;(); Random random = new Random(47); for(int i=0; i&lt;10; i++) &#123; priorityQueue.offer(random.nextInt(i+10)); &#125; QueueDemo.printQ(priorityQueue); List&lt;Integer&gt; ints = Arrays.asList(25,22,20,18,14,9,3,1,1,2,2,3,9,14,18,21,23,25); priorityQueue = new PriorityQueue&lt;Integer&gt;(ints); QueueDemo.printQ(priorityQueue); priorityQueue = new PriorityQueue&lt;Integer&gt;(ints.size(),Collections.reverseOrder()); priorityQueue.addAll(ints); QueueDemo.printQ(priorityQueue); String fact = &quot;EDUCATION SHOULD ESCHEW OBFUSCATION&quot;; List&lt;String&gt; strings = Arrays.asList(fact.split(&quot;&quot;)); PriorityQueue&lt;String&gt; stringPQ = new PriorityQueue&lt;String&gt;(strings); QueueDemo.printQ(stringPQ); stringPQ = new PriorityQueue&lt;String&gt;(strings.size(),Collections.reverseOrder()); stringPQ.addAll(strings); QueueDemo.printQ(stringPQ); Set&lt;Character&gt; charSet = new HashSet&lt;Character&gt;(); for(char c : fact.toCharArray()) charSet.add(c); PriorityQueue&lt;Character&gt; characterPQ = new PriorityQueue&lt;Character&gt;(charSet); QueueDemo.printQ(characterPQ); &#125;&#125; 1234567Output: 0 1 1 1 1 1 3 5 8 14 1 1 2 2 3 3 9 9 14 14 18 18 20 21 22 23 25 25 25 25 23 22 21 20 18 18 14 14 9 9 3 3 2 2 1 1 A A B C C C D D E E E F H H I I L N N O O O O S S S T T U U U W W U U U T T S S S O O O O N N L I I H H F E E E D D C C C B A A A B C D E F H I L N O S T U W]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合之添加元素]]></title>
    <url>%2F2018%2F03%2F28%2F2018-03-29-%E9%9B%86%E5%90%88%E4%B9%8B%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[在java.util包中的Arrays和Collections类中都有很多实用的方法，可以在Collection中添加一组元素。 Arrays.asList()方法接受一个数组或是一个用逗号分隔的元素列表（实用可变参数），并将其转换为一个List对象。 Collections.addAll()方法接受一个collection对象，以及一个数组或是一个用逗号分割的列表，将元素添加到Collection中。 12345678910111213141516171819public class AddingGroups &#123; public static void main(String args[]) &#123; Collection&lt;Integer&gt; collection = new ArrayList&lt;Integer&gt;(Arrays.asList(1,2,3,4,5)); Integer[] moreInts = &#123;6,7,8,9,10&#125;; collection.addAll(Arrays.asList(moreInts)); Collections.addAll(collection, 11,12,13,14,15); Collections.addAll(collection, moreInts); List&lt;Integer&gt; list = Arrays.asList(16,17,18,19,20); list.set(1, 99); //list.add(21);// for(Integer i : list) &#123;// System.out.println(i);// &#125; for(Integer i : collection) &#123; System.out.println(i); &#125; &#125;&#125; 上面注释掉的list.add(21)运行时会报：Runtime error because the underlying array cannot be resized.可以将Arrays.asList()的输出作为List，但是在这种情况下，其底层表示的是数组，因此不能调整尺寸。如果试图用add()或delete()方法在这种列表中添加或删除元素，就可能引发改变数组尺寸的尝试，因此将在运行时获取“Unsupported Operation(不支持的操作)”错误。Collection.addAll()成员方法只能接受一个Collection对象作为参数，因此它不如Arrays.asList()和Collections.addAll()灵活，整两个方法使用的都是可变参数列表。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合（3）]]></title>
    <url>%2F2018%2F03%2F28%2F2018-03-28-java%E9%9B%86%E5%90%883%2F</url>
    <content type="text"><![CDATA[泛型 定义泛型是一种把明确类型的工作放在了创建对象或调用方法时采取明确的特殊的类型。 格式&lt;数据类型&gt;1ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 即表示是泛型。 泛型的好处 解决了黄色警告线问题 把运行期间的转换异常提前到了编译期间 优化了程序设计，不需要做强制类型转换了 泛型的发展 泛型类 泛型方法 泛型接口 泛型的使用看API中的类或者接口，其后带有&lt;&gt;就是泛型的应用。一般在集合中。 增强for循环（JDK1.5之后新特性） 格式123for(数组或者Collection集合的元素类型 变量 ： 数组或者Collection集合的对象)&#123; 直接使用变量&#125; 举例：1234567891011public static void main(String[] args)&#123; Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); map.put(&quot;二阳&quot;,23); map.put(&quot;二蛋&quot;,24); map.put(&quot;二光&quot;,25); Set&lt;String&gt; keys = map.keySet(); for(String key : keys)&#123; Integer value = map.get(key); System.out.println(key+&quot;***&quot;+value); &#125;&#125; 好处方便了数组和Collection集合的遍历。 注意 增强for是用来替代迭代器的 不要在用增强for遍历集合的时候，用集合对集合本身进行修改 遍历集合三种方式(1) 迭代器(2) 普通for+get()(3) 增强for(工作时用) 工具类常用到的工具类有两种，Collections和Arrays，如下图： 参考文献：https://blog.csdn.net/haovip123/article/details/45425021]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合（2）]]></title>
    <url>%2F2018%2F03%2F27%2F2018-03-27-java%E9%9B%86%E5%90%882%2F</url>
    <content type="text"><![CDATA[迭代器的使用使用步骤： 通过集合对象获取迭代器 通过迭代器对象判断 通过迭代器对象获取 迭代器原理由于多种集合的数据结构不同，所以存储方式不同，所以，取出方式也不同。这时候我们就把判断和获取功能定义在一个接口中，将来，遍历哪种集合的时候，只要该集合内部实现该接口即可。 迭代器源码12345678910111213141516171819202122public interface Iterator&#123; public abstract boolean hasNext(); public abstract Object next();&#125;public interface Collection&#123; public abstract Iterator iterator();&#125;public interface List extends Collection&#123; ...&#125;public class ArrayList implements List&#123; public Iterator iterator()&#123; return Itr(); &#125; private class Itr implements Iterator&#123; public boolean hasNext()&#123;...&#125; public Object next()&#123;...&#125; &#125;&#125; Collection存储字符串和自定义对象并通过迭代器遍历 存储字符串 12345678910Collection c = new ArrayList();c.add(&quot;hello&quot;);c.add(&quot;world&quot;);c.add(&quot;java&quot;);Iterator it = c.iterator();while(it.hasNext())&#123; String s = (String)it.next(); System.out.println(s);&#125; 存储自定义对象 12345678Collection c = new ArrayList();Student s1 = new Student1(&quot;林青霞&quot;,26);//Student类的定义省略c.add(s1);Iterator it = c.iterator();while(it.hasNext())&#123; String s = (String)it.next(); System.out.println(s);&#125; ListLiterator迭代器是Iterator的子接口，所以List的遍历方式有三种： Iterator迭代器 ListIterator迭代器 普通for+get() MapMap是一个键值形式的集合，它的元素都是有键和值组成。Map的键(Key)是唯一的，值(value)可以重复。 Map的功能A：添加功能V put(K key,V value):当key在集合中不存在时添加元素，当key存在时替换元素 B：判断功能boolean containsKey(Object key):判断指定的键在集合中是否存在 boolean containsValue(Object value):判断指定的值在集合中是否存在 boolean isEmpty():判断集合是否为空 C：删除功能void clear():清除所有键值对数据 D：获取功能Object get(Object key):根据键获取值 Set&lt;Key&gt; keySet():所有键的集合 Collection&lt;V&gt; values():所有值的集合 E：长度功能int size() Map包括HashMap、HashTable和TreeMap。其中，HashTable已经被HashMap取代，这里不做讨论（HashMap支持null，HashTable不支持null）。 Map遍历的两种方式 键找值 1234567891011public static void main(String[] args)&#123; Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); map.put(&quot;二阳&quot;,23); map.put(&quot;二蛋&quot;,24); map.put(&quot;二光&quot;,25); Set&lt;String&gt; keys = map.keySet(); for(String key : keys)&#123; Integer value = map.get(key); System.out.println(key+&quot;***&quot;+value); &#125;&#125; 键值对 12345678910111213public static void main(String[] args)&#123; Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); map.put(&quot;二阳&quot;,23); map.put(&quot;二蛋&quot;,24); map.put(&quot;二光&quot;,25); Set&lt;Map.Entry&lt;String,Integer&gt;&gt; set = map.entrySet();//获取键值对集合 for(Map.Entry&lt;String,Integer&gt; me:set)&#123; String key = me.getKey(); Integer value = me.getValue(); System.out.println(key+&quot;***&quot;+value); &#125;&#125; 参考文献：https://blog.csdn.net/haovip123/article/details/45424711]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合（1）]]></title>
    <url>%2F2018%2F03%2F27%2F2018-03-27-Java%E9%9B%86%E5%90%881%2F</url>
    <content type="text"><![CDATA[集合概述Java是一种面向对象的语言，如果要针对多个对象进行操作，就必须对多个对象进行存储。而数组长度固定，不能满足变化的要求。所以，Java提供了集合。特点： 长度可以发生变化 只能存储对象 可以存储多种类型对象集合和数组的区别：数组：长度固定，可以存储基本类型和引用类型，元素类型必须一致集合：长度可变，可以存储引用类型，元素类型可以不一致 集合体系集合作为一个容器，可以存储多个元素，但是由于数据结构的不同，Java提供了多种集合类。将集合类中共性的功能，不断向上抽取，最终形成了集合体系结构。数据结构：数据存储的方式Java集合类的关系图： CollectionCollection是最基本的集合接口，一个collection代表一组Object，即Collection的元素（Elements）。一些Collection允许存储相同的元素而另一些不行。一些能排序而另一些不行，于是衍生出两个字类接口List和Set。 Collection基本功能A：添加功能boolean add(Object obj):向集合中添加一个元素 boolean addAll(Collection c):向集合中添加一个集合元素 B：删除功能void clear():删除集合中的所有元素 boolean remove(Object obj):从集合中删除指定的元素 boolean removeAll(Collection c):从集合中删除一个指定的集合元素 C：判断功能boolean isEmpty():判断集合是否为空 boolean contains(Object obj):判断集合中是否存在指定的元素 boolean containsAll(Collection c):判断集合中是否存在指定的一个集合中的元素 D：遍历功能Iterator iterator():就是用来获取集合中的没有给元素 E：长度功能int size():获取集合中元素的个数 F：交集功能boolean retainAll(Collection c):判断两个集合中是否有相同的元素 G：把集合转换为数组Object[] toArray():把集合变成数组 List接口List接口下的集合元素存储有序，可以重复List的特有功能： A：添加功能void add(int index, Object obj):在指定位置添加元素 B：删除功能Object remove(int index):根据指定索引删除元素，并把删除的元素返回 C：修改功能Object set(int index,Object obj):把指定索引位置的元素修改为指定的值，返回修改前的值 D：获取功能int indexOf(Object o):返回指定元素在集合中第一次出现的索引 Object get(int index):获取指定位置的元素 ListIterator(int fromIndex,int toIndex):截取集合 Set集合set接口下的元素无序，不可以重复。其下面分为HashSet和TreeSet。 HashSet底层数据结构是哈希表，线程不安全，效率高。保证唯一性依赖两个方法：hashCode()和equals()。顺序： 判断hashCode()值是否相同。 相同：继续走equals()，看返回值 如果true：就不添加到集合 如果false：就添加到集合 不同：就添加到集合 TreeSet底层数据结构是二叉树，线程不安全，效率高。保证元素唯一性是根据返回值是否为0.保证排序的两种方式： 自然排序（元素具备比较性）：实现Comparable接口 比较排序（集合具备比较性）：实现Comparable接口 参考资料：https://blog.csdn.net/haovip123/article/details/45423683]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java内部类(4)]]></title>
    <url>%2F2018%2F03%2F26%2F2018-03-26-%E5%86%85%E9%83%A8%E7%B1%BB4%2F</url>
    <content type="text"><![CDATA[Java四种内部类使用细节。 静态内部类（内部类中最简单的形式） 声明在类体部，方法体外，并且使用static修饰的内部类 访问特点可以类比静态变量和静态方法 脱离外部类的实例独立创建在外部类的外部创建内部类的实例：new Outer.Inner();在外部类的内部创建内部类的实例：new Inner(); 静态内部类体部可以直接访问外部类中所有的静态成员，包含私有 123456789101112131415161718192021222324252627282930313233public class StaticInnerTest &#123; public static void main(String[] args) &#123; StaticOuter.StaticInner si = new StaticOuter.StaticInner(); si.test2(); System.out.println(&quot;si.b = &quot;+si.b); System.out.println(&quot;si.a = &quot;+si.a); &#125;&#125;class StaticOuter&#123; private int a = 100; private static int b = 150; public static void test() &#123; System.out.println(&quot;Outer static test...&quot;); &#125; public void test2() &#123; System.out.println(&quot;Outer instabce test...&quot;); &#125; static class StaticInner&#123; public int a = 200; static int b = 300; public static void test() &#123; System.out.println(&quot;Inner static test...&quot;); &#125; public static void test2() &#123; System.out.println(&quot;Inner instabce test...&quot;); StaticOuter.test(); new StaticOuter().test2(); System.out.println(&quot;StaticOuter.b = &quot;+StaticOuter.b); &#125; &#125;&#125; 成员内部类（实例内部类） 没有static修饰的内部类 在成员内部类中不允许出现静态变量和静态方法的声明，static只能用在静态常量的声明上 成员内部类中可以访问外部类中所有的成员（变量、方法），包含私有成员，如果在内部类中定义有和外部类同名的实例变量，访问：OuterClass.this.outerMember; 构建内部类的实例，要求必须外部类的实例先存在外部类的外部/外部类的静态方法：new Outer().new Inner();外部类的实例方法：new Inner(); this.new Inner(); 1234567891011121314151617181920212223242526272829303132333435public class MemberInnerTest &#123; public static void main(String[] args) &#123; MemberOuter mo = new MemberOuter(); mo.setS1(&quot;&quot;); &#125;&#125;class MemberOuter&#123; private String s1 = &quot;Outer InstanceMar&quot;; private String s2 = &quot;OuterStatic s2&quot;; public void setS1(String s1) &#123; this.s1 = s1; new MemberOuter().new MemberInner(); this.new MemberInner();//此时MemberOuter已经实例化，所以可以使用this new MemberInner().test2(); &#125; public static void test2() &#123; new MemberOuter().new MemberInner(); /* * this.new MemberInner(); * 此时MemberOuter没有实例化完成，所以不能使用this * static 是在MemberOuter构造器前使用，所以此时不能使用this */ &#125; class MemberInner&#123; String s1 = &quot;Inner InstanceMae&quot;; static final String s4 = &quot;static final MemberInner&quot;; void test2() &#123; System.out.println(&quot; s1 = &quot;+s1); System.out.println(&quot; Outter MemberOuter.this.s1 = &quot;+MemberOuter.this.s1); System.out.println(&quot; s2 = &quot;+s2); &#125; &#125;&#125; 局部内部类 定义在方法体甚至比方法体更小的代码块中 类比局部变量 局部内部类是所有内部类中最少使用的一种形式 局部内部类可以访问的外部类成员根据所在方法体不同如果在静态方法中：可以访问外部类的所有静态成员，包含私有如果在实例方法中：可以访问外部类的所有成员，包含私有局部内部类可以访问所在方法中定义的局部变量，但是要求局部变量必须用final修饰 123456789101112131415161718192021222324252627282930313233343536public class LocalInnerTest &#123; private int a = 1; private static int b = 2; public void test() &#123; final int c = 3; class LocalInner &#123; public void add1() &#123; System.out.println(&quot;a= &quot; + a); System.out.println(&quot;b= &quot; + b); System.out.println(&quot;c= &quot; + c); &#125; &#125; new LocalInner().add1(); &#125; static public void test2() &#123; final int d = 5; class LocalInner2 &#123; public void add1() &#123; // System.out.println(&quot;a= &quot; + a); System.out.println(&quot;b= &quot; + b); System.out.println(&quot;c= &quot; + d); &#125; &#125; new LocalInner2().add1(); &#125; public static void main(String args[]) &#123; // LocalInnerTest() lc = new LocalInnerTest(); new LocalInnerTest().test2(); new LocalInnerTest().test(); &#125; &#125; 匿名内部类 没有名字的局部内部类 没有class、interface、implements、extends关键字 没有构造器 一般隐式的集成某一个父类或者实现某一个接口 123456789101112131415161718192021222324252627282930313233343536** * @author gress 匿名内部类,我只会使用一次的类 * * 就假如我想吃一个泡面,但我不可能建一个厂,制造一个流水线,生产一包泡面之后就在也不去使用这个泡面厂了 * 所以这里引申出匿名内部类 ,而我们建立的泡面厂就像这里构建的一个类Pencil 铅笔类一样 */ interface Pen &#123; public void write(); &#125; class Pencil implements Pen &#123; @Override public void write() &#123; //铅笔 的工厂 &#125; &#125; class Person &#123; public void user(Pen pen) &#123; pen.write(); &#125; &#125; public class AnyInnerTest &#123; public static void main(String args[]) &#123; Person guo = new Person(); guo.user(new Pen() &#123; @Override public void write() &#123; System.out.println(&quot;写子&quot;); &#125; &#125;); &#125; &#125; 参考文章：https://blog.csdn.net/qq_33599978/article/details/70880803]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java内部类(3)]]></title>
    <url>%2F2018%2F03%2F26%2F2018-03-26-%E5%86%85%E9%83%A8%E7%B1%BB3%2F</url>
    <content type="text"><![CDATA[由于每个类都是产生一个.class文件，其中包含了如何创建该类型的对象的全部信息（此信息产生一个“meta-class”，叫做Class对象）。内部类也必须产生一个.class文件以包含它们的Class对象信息。这些类文件的命名有严格的队则：外围类的名字，加上“$”，再加上内部类的名字。123456789101112131415161718192021222324252627282930313233343536public class LocalInnerClass &#123; private int count = 0; Counter getCounter(final String name) &#123; class LocalCounter implements Counter&#123; public LocalCounter() &#123; System.out.println(&quot;LocalCounter&quot;); &#125; public int next() &#123; System.out.println(name); return count++; &#125; &#125; return new LocalCounter(); &#125; Counter getCounter2(final String name) &#123; return new Counter() &#123; &#123; System.out.println(&quot;Counter()&quot;); &#125; public int next() &#123; System.out.println(name); return count++; &#125; &#125;; &#125; public static void main(String[] args) &#123; &#125;&#125;interface Counter&#123; int next();&#125; 上面程序的生成的.class文件包括： Counter.classLocalInnerClass$1.classLocalInnerClass$1LocalCounter.classLocalInnerClass 如果内部类是匿名的，编译器会简单地产生一个数字作为其标识符。如果内部类是嵌套在别的内部类之中，只需直接将它们的名字加在其外围类标识符与“$”的后面。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java内部类(2)]]></title>
    <url>%2F2018%2F03%2F26%2F2018-03-26-%E5%86%85%E9%83%A8%E7%B1%BB2%2F</url>
    <content type="text"><![CDATA[使用.this如果你需要声称对外部类对象的引用，可以使外部类的名字后面紧跟圆点和this，这样产生的引用自动的具有正确的类型，这一点在编译期就被知晓并受到检查，因此没有任何运行时开销。下面的例子展示了如何使用this:1234567891011121314151617181920public class DotThis &#123; void f() &#123; System.out.println(&quot;DotThis.f()&quot;); &#125; public class Inner&#123; public DotThis outer() &#123; return DotThis.this; &#125; &#125; public Inner inner() &#123; return new Inner(); &#125; public static void main(String[] args) &#123; DotThis dt = new DotThis(); DotThis.Inner dti = dt.inner(); dti.outer().f(); &#125;&#125; 使用.new有时你可能想告知某些其它对象，去创建其某个内部类的对象。要实现此目的，你必须在new表达式中提供对其他外部类对象的引用，这时需要用new语法，如下：1234567public class DotNew &#123; public class Inner&#123;&#125; public static void main(String[] args) &#123; DotNew dn = new DotNew(); DotNew.Inner dni = dn.new Inner(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java为什么要设置环境变量]]></title>
    <url>%2F2018%2F03%2F23%2F2018-03-23-java%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[环境变量环境变量：Environment variable变量：就是可以随意给其赋值的存储单元。环境：可以把操作系统当做一个最大的软件，其他软件比如office、LOL、JVM等都是运行在这个大软件内的小软件。那么环境就是指这个操作系统。环境变量：就是指操作系统中某个软件中变量，也就是：全局变量。作用：变量在任何程序中的作用都是被赋值/被使用！这个全局变量操作系统可以使用，其它小软件也可以使用。 java环境变量设置环境变量大体上是给操作系统的直接上层程序使用的，比如Linux中的shell、.sh文件，Windows中的cmd、.bat文件。PATH这是其实是操作系统用的，用来指定操作系统需要使用到的程序的位置。对java来说，通常需要把jdk的bin目录放入path中，这样就可以在任意目录下使用bin下面的javac.exe、java.exe等。这个变量一定要保证将JRE/jdk纳入其中（这里其实不严谨，你可以把javaw.exe等这类文件复制一份放到任意一个path路径下，不一定是jre/jdk也行），这样很多java程序才能启动，比如eclipse。JAVA_HOMEJAVA_HOME:是一个约定，通常它指的是jdk目录。如果需要jdk的话，大部分程序会默认去环境变量中取JAVA_HOME这个变量。比如，Tomcat的.bat/.sh文件中就会默认去取JAVA_HOME来用。所以，这个变量最需要设置。设置它，可保万无一失。JRE_HOME同样，这也是一个约定的变量，通常指JRE目录。其实大部分Java程序不需要jdk，而是只需要其子集JRE，所以也有很多程序会去取这个变量来用。例如Tomcat中某些.bat文件中这样说到：123456&lt;code class=&quot;language-bat hljs vbnet&quot;&gt;rem JAVA_HOME Must point at your Java Development Kit installation.rem Using JRE_HOME instead works as well.remrem JRE_HOME Must point at your Java Runtime installation.rem Defaults to JAVA_HOME if empty. If JRE_HOME and JAVA_HOMErem are both set, JRE_HOME is used.&lt;/code&gt; 大意就是，Tomcat去取这两个变量，只要任意一个不为空就行，都不为空就用JRE_HOME。因为Tomcat不需要jdk中的工具，它只是运行Java程序而已。这个变量如果你明确知道应用程序只需要设置这个就行（比如上面Tomcat的注释），那么它可以代替JAVA_HOME，且最好就用这个。CLASSPATH基本上，这个变量指的是：AppClassLoader加载的class路径。这个变量就跟所有java写的程序有关，不光其它Java程序会用到（比如Tomcat在某些情况会用），我们写的java程序也用到了。但其实，如果用eclipse的话你还是只需要点击一下BuildPath就行了，还是没有让你显式的用XXXX=XXXX这种方式。不过你用command line来运行java程序的话通常会用到classpath。可以在Java程序中用代码获取到当前classpath的内容，像这样：123&lt;code class=&quot;language-java hljs &quot;&gt;System.getProperty(&quot;java.class.path&quot;)//输出是String内容是你项目的class文件的根目录 + 你引用的jar包们的地址。类似这样E:\test1\target\classes;E:\Java\Program Files\.m2\repository\mysql\mysql-connector-java\5.1.38\mysql-connector-java-5.1.38.jar...&lt;/code&gt; 所以，这个变量在使用IDE进行开发的情况下，通常不需要手动设置，只需要按常规IDE使用步骤（比如Build path）IDE会帮我们做。 总结123JAVA_HOME:C:\Program Files\Java\jdk-9.0.1 (按照自己的jdk路径) CLASSPATH:.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar; (不要忘记前面的.) Path:%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin JAVA_HOME主要是给后面两个用的； CLASSPATH指定的是默认的类库的位置； PATH是让java的bin加入到系统路径中，这样命令行或其它程序就可以调用java、javac、javaw等命令了（到处可以使用这些命令）。 参考：https://www.2cto.com/kf/201605/506454.html]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javac不是内部或外部命令]]></title>
    <url>%2F2018%2F03%2F23%2F2018-03-23-javac%E4%B8%8D%E6%98%AF%E5%86%85%E9%83%A8%E6%88%96%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[首先将JAVA_HOME、CLASSPATH、Path配置好，123JAVA_HOME:C:\Program Files\Java\jdk-9.0.1 (按照自己的jdk路径) CLASSPATH:.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar; (不要忘记前面的.) Path:%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin 如果运行javac不是内部或者外部命令，就将Path配置为全路径：12C:\Program Files\Java\jdk-9.0.1\binC:\Program Files\Java\jre-9.0.1\bin 这样就可以使用javac命令了。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java内部类(1)]]></title>
    <url>%2F2018%2F03%2F22%2F2018-03-22-java%E5%86%85%E9%83%A8%E7%B1%BB1%2F</url>
    <content type="text"><![CDATA[什么是内部类内部类，顾名思义就是在内部的类就是内部类，可以是在类的内部，也可以是在接口的内部。内部类又分为以下几种：(1) 普通内部类(2) 匿名内部类(3) 嵌套内部类 普通内部类普通内部类就是在一个类内定义一个普通的类（也可以是定义一个类的方法内定义一个类，称为局部内部类），如下：123456789101112131415161718192021222324252627282930313233343536373839public class Parcel1 &#123; class Contents&#123; private int i = 11; public int value() &#123; return i; &#125; &#125; class Destination&#123; private String label; Destination(String whereTo)&#123; label = whereTo; &#125; String readLabel() &#123; return label; &#125; &#125; public Destination to(String s) &#123; return new Destination(s); &#125; public Contents contents() &#123; return new Contents(); &#125; public void ship(String dest) &#123; Contents c = new Contents(); Destination d = new Destination(dest); System.out.println(d.readLabel()); &#125; public static void main(String[] args) &#123; Parcel1 p = new Parcel1(); p.ship(&quot;Tasmania&quot;); Parcel1 q = new Parcel1(); Parcel1.Contents c = q.contents(); Parcel1.Destination d = q.to(&quot;Borneo&quot;); &#125;&#125; 从上面的代码可以看出，如果想在外部类的非静态方法之外的任意位置创建某个内部类的对象，必须按照这个格式：OuterClassName.InnerClassName。当生成一个内部类对象时，此对象与制造它的外围对象之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何特殊条件。此外，内部类还拥有外围类的所有元素的访问权（即使是private）。我自己变成测试，内部类的对象不能访问其外围对象的成员，但是在内部类内可以访问其外围类的成员。123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Sequence &#123; private Object[] items; private int next = 0; public Sequence(int size) &#123; items = new Object[size]; &#125; public void add(Object x) &#123; if(next &lt; items.length) &#123; items[next++] = x; &#125; &#125; private class SequenceSelector implements Selector&#123; private int i = 0; public boolean end() &#123; return i == items.length; &#125; public Object current() &#123; return items[i]; &#125; public void next() &#123; if(i&lt;items.length) &#123; i++; &#125; &#125; &#125; public Selector selector() &#123; return new SequenceSelector(); &#125; public static void main(String[] args) &#123; Sequence sequence = new Sequence(10); for(int i = 0; i &lt; 10; i++) sequence.add(Integer.toString(i)); Selector selector = sequence.selector(); while(!selector.end()) &#123; System.out.println(selector.current() + &quot; &quot;); selector.next(); &#125; &#125;&#125;interface Selector&#123; boolean end(); Object current(); void next();&#125; 总结：(1) 内部类自动拥有外围类所有成员（包括private成员）的访问权限；(2) 在外位类的静态方法中创建内部类的对象需要指明其具体类型，要按照格式：OuterClassName.InnerClassName 匿名内部类匿名内部类就是没有类名的类，听起来很奇怪，举个例子： 12345678910111213141516171819public class Parcel7 &#123; public Contents contents() &#123; return new Contents() &#123; private int i = 11; public int value() &#123; System.out.println(&quot;i:&quot;+i); return i; &#125; &#125;; &#125; public static void main(String[] args) &#123; Parcel7 p = new Parcel7(); Contents c = p.contents(); &#125;&#125;interface Contents&#123; int value();&#125; 在上面的方法contengs()中，将返回值的生成与表示这个返回值的类的定义结合在一起。另外这个类是匿名的，看起来像是你正要创建一个C对象，但是然后你却说：“等一等，我想在这里插入一个类的定义。”定义一个匿名类，要么继承一个类（或者抽象类），要么实现一个接口。 如果定义一个匿名类，并且希望使用一个在其外部定义的对象，那么编译器会要求其参数是final的。 嵌套类如果不需要内部类对象与外围类对象之间有联系，那么可以将内部类声明为static。想要理解static应用于内部类是的含义，就必须记住，普通的内部类对象隐式地保存了一个引用，指向创建它的外围类对象。然而，当内部类是static时，就不是这样了。嵌套类意味着： 要创建嵌套类的对象，并不需要其外围类的对象。 不能从嵌套类的对象中访问非静态的外围类对象。 1234567891011public class F&#123; private static class G implements C&#123; private String str = &quot;static class G&quot;; public void run()&#123; System.out.println(&quot;run &quot;+str); &#125; public void speak()&#123; System.out.println(&quot;speak &quot;+str); &#125; &#125;&#125; 总结： 嵌套类没有链接到外围类对象的this引用，这使得它像一个static方法。 脱离外部耒的实例独立创建，在外部类的外部创建内部类的实例：new Outer.Inner();在外部类的内部创建内部类的实例：new Inner(); 静态内部类可以直接访问外部类中所有的静态成员，包含私有。 为什么需要内部类(1) 内部类提供了更好的封装，只有外部类才能访问内部类；(2) 内部类可以独立继承一个接口，不受外部类是否是否继承接口的影响；(3) 内部类中的方法和属性即使是外部类也不能访问，相反内部类可以直接访问外部类的属性和方法，即使是private；(4) 利于回调函数的编写。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金银价格与美联储加息之3月22]]></title>
    <url>%2F2018%2F03%2F22%2F2018-03-22-%E9%BB%84%E9%87%91%E7%99%BD%E9%93%B6%E4%BB%B7%E6%A0%BC%E4%B8%8E%E7%BE%8E%E8%81%94%E5%82%A83%E6%9C%88%E5%8A%A0%E6%81%AF%2F</url>
    <content type="text"><![CDATA[2018年3月22日凌晨，美联储不出预料的加息25个基点，完全符合预期。金银价格在加息时几乎没有大的波动，因为市场已经预期到美联储会加息，所以在加息之前，市场已经做出反应。相反，金银价格在美联储宣布加息时金银的价格出现了反弹上升。金价走势如下：白银T+D价格走势如下：]]></content>
      <categories>
        <category>economy</category>
      </categories>
      <tags>
        <tag>economy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java抽象类和接口]]></title>
    <url>%2F2018%2F03%2F19%2F2018-03-19-java%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[在java中，可以通过两种方式来体现OOP的抽象：接口和抽象类。这两者有太多相似的地方，又有太多不同的地方。 抽象类在了解抽象类之前，先了解一下抽象方法。抽象方法是一种特殊的方法，它只有声明，而没有具体的实现。抽象方法的实现各式：1abstract void fun(); 抽象方法必须用abstract关键字进行修饰。如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用abstract关键字修饰。因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。下面要注意一个问题：在《java编程思想》一书中，将抽象类定义为“包含抽象方法的类”，但是后面发现如果一个类不包含抽象方法，只是用abstract修饰的话也是抽象类。也就是说抽象类不一定必须含有抽象方法抽象方法。123[public] abstract class ClassName&#123; abstract void fun();&#125; 从这里可以看出抽象类就是为了继承而存在的，如果定义了一个抽象类而不去继承，那么等于白白创建了这个抽象类，因为不能用它来做任何事。对于一个父类，如果它的某个方法在父类中实现出来没有任何意义，必须根据子类的实际需求来进行不同的实现，那么就可以将这个方法声明为abstract方法，此时这个类也就称为abstract类了。包含抽象方法的类称为抽象类，但并不意味着抽象类中只有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法。注意，抽象类和普通类主要有三点区别：(1) 抽象方法必须为public或者protected（如果为private则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public；(2) 抽象类不能创建对象；(3) 如果一个类继承于抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。在其它方面抽象类和普通类没有什么区别。 接口接口，英文称作interface，在软件工程中，接口泛指供别人调用的方法或函数。从这里我们可以体会到java语言设计者的初衷，它是对行为的抽象。在java中定义一个接口的形式如下：123[public] interface InterfaceName&#123;&#125; 接口中可以含有变量和方法。但是要注意，接口中的变量会被隐式地指定为public static final（并且只能是public static final变量，用private修饰会报编译错误），而方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其它关键字，比如private、protected、static、final等修饰会报编译错误），并且接口中所有的方法不能有具体实现，也就是说，接口中的方法必须是抽象方法。从这里隐约可以看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加抽象，并且在一般情况下不在接口中定义变量。要让一个类遵循某组特定的接口需要使用implements关键字，具体格式如下：123class ClassName implements Interface1, Interface2,[....]&#123;&#125; 可以看出，允许一个类遵循多个特定的接口。如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。 抽象类和接口的区别 语法层面上的区别(1) 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract方法；(2) 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型；(3) 抽象类中可以有静态代码块和静态方法，而接口中不能含有静态代码块和静态方法；(4) 一个类只能继承一个抽象类，而一个类可以实现多个接口。 设计层面上的区别(1) 抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但它们有一个共性，就是会飞。那么在设计的时候，将飞机可以设计为一个类Airplane，将鸟设计为一个类Bird，但是不能讲飞行这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将飞行设计为一个接口Fly，包含方法fly()，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同类型的飞机，比如战斗机、民用飞机，直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个“是不是”的关系，而接口实现则是“有没有”的关系。如果一个类继承了某个抽象类，则子类必须是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。(2)设计层面上，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单的例子，大家都用过PPT里面的模板，如果用模板A设计了PPT B和PPT C，PPT B和PPT C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改变模板A就可以了，不需要重新对PPT B和PPT C进行改动。而辐射式设计，比如某个电梯都安装了某种警报器，一旦要更新警报器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，则可以在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则实现这个接口的类都需要进行相应的改动。 下面看一个网上流传最广泛的例子：门和警报的例子：门都有open()和close()两个动作，此时我们可以通过抽象类和接口来定义这个抽象概念：1234abstract class Door&#123; public abstract void open(); public abstract void close();&#125; 或者：1234interface Door&#123; public abstract void open(); public abstract void close();&#125; 但是现在如果我们需要门具有警报alarm()的功能，那么该如何实现呢？下面提供两种思路：(1) 将这三个功能都放在抽象类中，但是这样所有继承这个抽象类的的子类都具有了警报功能，但是有的门并不一定具有警报功能；(2) 将三个功能都放在接口中，需要用到警报的类就实现这个接口中的open()和close()，也许这个类根本就不需要open()和close()这两个功能，比如火灾警报器。从这里可以看出，Door的open()和close()和alarm()根本就属于两个不同范畴的内的行为，open()和close()属于门本身固有行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法单独将警报设计为一个接口，包含alarm()行为，Door设计为一个单独的抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。1234567891011121314151617181920interface Alarm&#123; void alarm();&#125;abstract class Door&#123; void open(); void close();&#125;class AlarmDoor extends Door implements Alarm&#123; void open()&#123; //... &#125; void close()&#123; //... &#125; void alarm()&#123; //... &#125;&#125; 参考资料：http://www.importnew.com/18780.html]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多态]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-19-java%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[面向对象的三大特征：封装、继承、多态。从一定角度来看，封装和继承几乎都是为多态而准备的。 定义多态：指允不同类的对象对同一消息做出相应。即同一消息可以根据发送对象的不同而采用多种不同的方式。（发送消息就是函数调用） 实现多态的技术实现多态的技术：动态绑定，是指在执行期间判断所引用对象的实际类型，根据实际的类型调用其相应的方法。 作用消除类型之间的耦合关系。 举例现实中，关于多态的例子不胜枚举。比如按下F1键这个动作，如果当前在Flash界面下弹出的就是AS3帮助文档；如果当前在word下弹出的就是Word帮助；在Windows下弹出的就是windows帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。 多态存在的三个必要条件要求大家做梦的时候都要背出来，多态存在的三个条件： 要有继承 要有重写 父类引用指向子类对象 多态的好处 可替换性(substitutability)：多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其它任何圆形几何体，如圆环，也同样工作。 可扩充性(extensibility)：多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其它特性的运行和操作。实际上增加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多台基础上，很容易增加球体的多态性。 接口性(interface-ability)：多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现。 灵活性(flexibility)：它在应用中体现了灵活多样的操作，提高了使用效率。 简化性(simpllicity)：多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。 总结面向对象编程有三大特性：封装、继承、多态。 封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。 继承是为了重用父类代码。两个类若存在IS-A的关系就可以使用继承。，同时继承也为实现多态做了铺垫。那么什么是多态呢？多态的实现机制又是什么？请看我一一为你揭开： 所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。 比如你是一个酒神，对酒情有独钟。某日回家发现桌上有几个杯子里面都装了白酒，从外面看我们是不可能知道这是些什么酒，只有喝了之后才能够猜出来是何种酒。你一喝，这是剑南春、再喝这是五粮液、再喝这是酒鬼酒….在这里我们可以描述成如下： 酒 a = 剑南春 酒 b = 五粮液 酒 c = 酒鬼酒 … 这里所表现的的就是多态。剑南春、五粮液、酒鬼酒都是酒的子类，我们只是通过酒这一个父类就能够引用不同的子类，这就是多态——我们只有在运行的时候才会知道引用变量所指向的具体实例对象。 诚然，要理解多态我们就必须要明白什么是“向上转型”。在继承中我们简单介绍了向上转型，这里就在啰嗦下：在上面的喝酒例子中，酒（Win）是父类，剑南春（JNC）、五粮液（WLY）、酒鬼酒（JGJ）是子类。我们定义如下代码： JNC a = new JNC(); 对于这个代码我们非常容易理解无非就是实例化了一个剑南春的对象嘛！但是这样呢？ Wine a = new JNC(); 在这里我们这样理解，这里定义了一个Wine 类型的a，它指向JNC对象实例。由于JNC是继承与Wine，所以JNC可以自动向上转型为Wine，所以a是可以指向JNC实例对象的。这样做存在一个非常大的好处，在继承中我们知道子类是父类的扩展，它可以提供比父类更加强大的功能，如果我们定义了一个指向子类的父类引用类型，那么它除了能够引用父类的共性外，还可以使用子类强大的功能。 静态方法不具有多态性；构造器实际上是static方法，只不过该static声明是隐式的。 参考：http://www.importnew.com/20079.html和https://www.cnblogs.com/mz-lover/p/4786337.html]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[final关键字]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-18-final%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[java的final关键字通常指“这是无法改变的”，使用到final的三种情况：变量、方法、类。 final关键字的基本用法修饰类当用final修饰一个类时，表明这个类不能被继承。也就是说，如果你想让一个类不被继承，可以用final来修饰它。final类中的成员变量也可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为final。 修饰方法下面摘自《Java编程思想》：“使用final方法的原因有两个。第一个原因是把方法锁定，以防止任何继承类修改它的含义；第二个原因是效率。在早期的Java版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行优化了。”因此，只有在明确禁止该方法在子类中被覆盖的情况下才将方法设置为final的。类的private方法会被隐式地指定为final方法。 修饰变量对于一个final变量，如果是基本数据类型的变量，则其数值一旦在被初始化后便不能更改；如果是引用类型的变量，则其在被初始化后不能再被指向另一个变量了。 深入理解final关键字类的final变量和基本变量有什么区别？当用final作用于类的成员变量（注意是成员变量，局部变量只要保证在使用之前被初始化即可）必须在定义是或构造器中进行初始化赋值，而且final变量一旦被初始化之后就不能再被赋值了。看下面的例子：1234567891011public class Test&#123; public class void main(String[] args)&#123; String a = &quot;hello2&quot;; final String b = &quot;hello&quot;; String d = &quot;hello&quot;; String c = b+2; String e = d+2; System.out.println(a == c); System.out.println(a == e); &#125;&#125; 123Output: true false 为什么第一个结果为true，第二个结果为false？这里面就是final变量和普通变量的区别了，当final是基本数据类型和String类型时，如果在编译期间就知道它的确切值，则编译器会把它当做编译期常量使用。也就是说在用到该final变量的地方，相当于直接访问这个常量，不需要在运行时确定。因此在上面的一段代码中，由于变量b被final修饰，因此会被当做编译器常量，所以在用到b的地方会直接将变量b替换为它的值。而对于变量d的访问需要在运行时通过链接来进行。不过要注意，只有在编译期间能确切知道final变量值的情况下，编译器才会进行这样的优化。比如下面这段代码就不会进行优化：123456789101112public class Test&#123; public static void main(String[] args)&#123; String a = &quot;hello2&quot;; final String b = getHello(); String c = b+2; System.out.println(a == c); &#125; public static String getHello()&#123; return &quot;hello&quot;; &#125;&#125; 12Output: false 被final修饰的引用变量指向的内容可变吗？在上面提到final修饰的引用变量一旦初始化赋值后就不能再指向其它的对象，那么该引用变量指向的对象的内容可变吗？看下面这个例子：12345678910public class Test&#123; public static void main(String[] args)&#123; final MyClass myClass = new MyClass(); System.out.println(++myClass.i); &#125;&#125;class MyClass&#123; public int i = 0;&#125; 这段代码可以顺利通过编译并输出结果，输出结果为1。这说明引用变量被final修饰之后，虽然不能再指向其它对象，但它指向的对象的内容可以改变。 final和static很多时候会容易把static和final关键字混淆，static只用于成员变量用来表示只保存一份副本，而final的作用是保证变量不可变。看下面的例子：123456789101112131415public class Test&#123; public static void main(String[] args)&#123; MyClass myClass1 = new MyClass(); MyClass myClass2 = new MyClass(); System.out.println(myClass1.i); System.out.println(myClass1.j); System.out.println(myClass2.i); System.out.println(myClass2.j); &#125;&#125;class MyClass&#123; public final double i = Math.random(); public static double j = Math.random();&#125; 运行这段代码会发现，每次打印的两个j值是一样的，而i的值是不同的，这里就可以知道final和static的区别了。 final参数java允许在参数列表中以声明的方式将参数指明为final。这意味着你无法在方法中更改参数引用所指向的对象。12345678910111213class Gizmo&#123; public void spin()&#123;&#125;&#125;public class FinalArguments&#123; void with(final Gizmo g)&#123; // g = new Gizmo(); //非法的，因为g是final的 &#125; void without(Gizmo g)&#123; g = new Gizmo(); //合法的，g不是final的 g.spin(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承之向上转型]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-18-java%E7%BB%A7%E6%89%BF%E4%B9%8B%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[“为新类提供方法”并不是继承技术中最重要的方面，最重要的方面是用来表现新类和基类之间的关系。这种关系可以用“新类是现有类的一种类型”这句话加以概括。12345678910111213class Instrument&#123; public void play()&#123;&#125; static void tune(Instrument instrument)&#123; instrument.play(); &#125;&#125;public class Wind extends Instrument&#123; public static void main(String[] args)&#123; Wind flute = new Wind(); Instrument.tune(flute); &#125;&#125; 上面例子中Instrument.tune(flute)这句代码，Wind类的对象竟然可以当做是Instrument类型作为参数传入tune()方法中，这意味着Wind对象也是一种类型的Instrument。这就是继承中的向上转型。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java继承]]></title>
    <url>%2F2018%2F03%2F17%2F2018-03-17-java%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[什么是继承多个类存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。其中多个类称为子类，单独这个类称为父类、基类或者超类。子类可以访问父类的非私有属性和行为。通过extends关键字让类与类之间产生继承关系。例如下面的例子：12345678910111213141516171819202122232425262728293031323334353637383940class Person &#123; private String name ; private int age ; public void setName(String name) &#123; this.name = name ; &#125; public void setAge(int age) &#123; this.age = age ; &#125; public String getName() &#123; return this.name ; &#125; public int getAge()&#123; return this.age ; &#125;&#125;class Student &#123; private String name ; private int age ; private String school ; public void setName(String name) &#123; this.name = name ; &#125; public void setAge(int age) &#123; this.age = age ; &#125; public void setSchool(String school) &#123; this.school = school ; &#125; public String getName() &#123; return this.name ; &#125; public int getAge()&#123; return this.age ; &#125; public String getSchool() &#123; return this.school ; &#125;&#125; Person类和Student类有相同属性和方法，通过继承可以修改为：1234567891011121314151617181920212223242526272829303132class Person &#123; private String name; private int age; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return this.name; &#125; public int getAge() &#123; return this.age; &#125;&#125;class Student extends Person &#123; // Student类继承了Person类&#125;public class TestDemo &#123; public static void main(String args[]) &#123; Student stu = new Student(); // 实例化的是子类 stu.setName(&quot;张三&quot;); // Person类定义 stu.setAge(20); // Person类定义 System.out.println(&quot;姓名：&quot; + stu.getName() + &quot;，年龄：&quot; + stu.getAge()); &#125;&#125; 继承的好处 提高了代码的复用性 让类与类之间产生了关系，是多态的前提继承的特点 java只支持单继承，不支持多继承，即一个类只能有一个父类 支持多层继承，例如： class A{} class B extends A{} class C extends B{} 这样类C就含有B和C所有的非私有属性和方法。 继承注意事项 如果类之间存在着：is a 的关系，就可以考虑使用继承。 不要为了继承部分功能而使用继承。 super和this有什么区别super是一个关键字，代表父类的存储空间标识，可以理解为父类的引用。 this代表对象的引用，谁调用就代表谁。 super代表当前子类对父类的引用。使用场景： 当子类和父类出现同名成员时，可以用super区分。 子类要调用父类构造器时，可以用super语句。super();和this();都是在构造函数的第一行，不能同时出现。 方法的重写子类中出现与父类一模一样的方法时（除了权限修饰符，权限修饰符大于等于不包括private，返回值类型、方法名、参数列表都相同），会出现覆盖操作，也称为重写或复写。父类私有方法子类看不到，所以父类私有方法的重写也就无从谈起。覆盖时注意： 子类方法权限一定要大于等于父类方法权限。 静态只能覆盖静态。覆盖使用的场景：当子类需要父类的功能，而功能主体子类有自己特有的内容时，可以复写父类中的方法，这样，既沿袭了父类的功能，又定义了子类特有的功能。 方法重写与重载有什么区别：(1) 方法的重写是用在子类与父类方法一模一样时，除权限修饰符，返回值类型、方法名、参数列表都相同。(2) 重载使用在同一个类中个方法方法名相同，参数列表不同（返回值类型没有关系）的情况。 子父类中构造方法的用法(1) 子类的初始化过程，首先回去执行父类的初始化动作。因为子类的构造方法中默认有一个super()。子类要使用父类的成员变量，这个初始化必须要在子类初始化之前完成。所以子类执行构造方法之前，会限制性父类的构造方法。(2) 如果父类没有无参构造方法： 使用super调用父类的带参构造方法。推荐方式。 使用this调用本身的其它构造方法。 静态块、构造代码块、构造方法的执行顺序：父类静态代码块——&gt;子类静态代码块——&gt;父类构造代码块——&gt;父类构造方法——&gt;子类构造代码块——&gt;子类构造方法 final关键字final是一个关键字，可以用于修饰类、成员变量、成员方法。特点：(1) 它修饰的类不能被继承。(2) 它修饰的成员变量是一个常量。(3) 它修饰的方法不能被子类重写。final修饰的常量定义一般都有书写规范，被final修饰的常量名称，所有字母都大写。final修饰的成员变量必须初始化，初始化的方法有两种，显示初始化和构造方法初始化，但不能两个一起初始化。 protected和friendly(缺省权限修饰)的区别重点看protected和fiendly两种权限的区别：对于protected成员变量，子孙类在任何地方都能访问（包内或者包外），但是对于friendly或者说默认成员变量，其实是不存在子孙类访问权限的概念的，就是说如果子孙类在包内，则可以访问，子孙类在包外则不可以访问。 参考文章：http://blog.csdn.net/dreamhua927/article/details/54837985。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java类与包]]></title>
    <url>%2F2018%2F03%2F17%2F2018-03-17-java%E7%B1%BB%E4%B8%8E%E5%8C%85%2F</url>
    <content type="text"><![CDATA[每一个.java文件里都只能有一个public类，而且public修饰的类与文件名相同。 一个.java文件里如果有多个类，即使每个类里都有main()方法，程序运行时也只会调用public类的main()方法。如果命令行运行哪个类，则执行哪个类的main()方法，如java Cleanser，即使Cleanser不是public类，也会执行Cleanser里的main()方法。 除了public类外，同一个.java文件里可以定义其它不是public修饰的类，编译后会产生多个.class文件，文件名与里面的类名一一对应。 package放在除注释以外的第一行代码。 包的命名规则为全部小写，中间的字母也全部小写。 访问权限 如果没有提供任何修饰词，则意味着它是包访问权限（或者修饰词是friendly）。 public表示每个人都可以使用。 private只有同一个类中可以访问，类外都没有访问权限。 protected：继承访问权限。（1）所有父类用protected修饰的方法和成员变量，子类都可以访问；（2）protected修饰的也表示包访问权限，即同一个包的可以访问。 一个类既不可以是private的，也不可以是protected的（除内部类外），所以仅有两个选择：包访问权限和public。如果不希望其它任何人对该类有访问权限，则可以把所有的构造器设置为private，从而阻止任何人创建该类的对象，但是有一个例外，就是你在该类的static成员内可以创建。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的枚举类型]]></title>
    <url>%2F2018%2F03%2F16%2F2018-03-16-Java%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[理解枚举类型枚举类型是一种特殊的数据类型，之所以特殊是因为它既是一种类（class）类型却又比类类型多了一些特殊的约束，但是这些约束的存在也造就了枚举类型的简洁性、安全性已经便捷性。 枚举的定义回忆一下下面的程序，这是在没有枚举类型时定义常量的常见方式：123456789101112131415public class DayDemo&#123; public static final int MONDAY =1; public static final int TUESDAY=2; public static final int WEDNESDAY=3; public static final int THURSDAY=4; public static final int FRIDAY=5; public static final int SATURDAY=6; public static final int SUNDAY=7;&#125; 上述的常量定义常量的方式称为int枚举模式，这样的定义方式并没有什么错，但它存在许多不足，如在类型安全和使用方便性上没有多少好处，如果存在定义int值相同的变量，混淆的几率还是很大的，编译器也不会提出任何警告，因此这种方式在枚举出现后并不提倡，现在我们用枚举类型重新定义上述常量，同时感受一下枚举定义的方式，如下定义周一到周日的常量：123enum Day&#123; MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY&#125; 相当简洁，在定义枚举类型时我们使用的关键字是enum，与class关键字类似，只不过前者是定义枚举类型，后者是定义类类型。枚举类型Day中分别定义了周一到周日的值，这里要注意，值一般是大写，多个值之间用都好分隔开。同时我们应该知道的是枚举类型可以像类类型一样，定义为一个单独的文件，当然也可以定义在其它类内部。更重要的是枚举常量在类型安全性和便捷性都很有保证，如果出现类型问题编译器也会提示我们改进，但务必记住枚举表示的类型其取值是必须有限的，也就是说每个值都可以是枚举出来的，比如上述的描述的一周七天。那么该如何使用呢？如下：1234567891011public class EnumDemo&#123; public static void main(String[] args)&#123; //直接引用 Day day = Day.MONDAY; &#125;&#125;//定义枚举类型enum Day&#123; MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY&#125; 枚举实现原理我们大概了解了枚举类型的定义与简单使用后，现在有必要了解一下枚举类型的基本实现原理。实际上使用enum关键字创建枚举类型并编译后，编译器会给我们生成一个相关的类，这个类继承了Java API中的java.lang.Enum类，也就是说通过关键字enum创建枚举类型在编译后事实上也是一个类类型而且该类继承自java.lang.Enum类。下面我们编译前面定义的EnumDemo.java并查看生成的class文件来验证这个结论：12345678//查看目录下的文件zejian@zejiandeMBP enumdemo$ 1sEnumDemo.java//利用javac命令编译EnumDemo.javazejian@zejiandeMBP enumdemo$ javac EnumDemo.java//查看生成的class文件，注意有Day.class和EnumDemo.class两个zejian@zejiandeMBP enumdemo$ 1sDay.class EnumDemo.class EnumDemo.java 用javac编译后生成Day.class和EnumDemo.class两个文件，而Day.class就是枚举类型，也就验证前面说的枚举类型编译后，编译器会自动帮助我们生成一个与枚举相关的类。我们再来看看反编译Day.class文件：123456789101112131415161718192021222324252627282930313233343536373839//反编译Day.classfinal class Day extends Enum&#123; //编译器为我们添加的静态的values()方法 public static Day[] values()&#123; return (Day[])$VALUES.clone(); &#125; //编译器为我们添加的静态的valueOf()方法，注意简介调用了Enum类的valueOf()方法 public static Day valueOf(String s)&#123; return (Day)Enum.valueOf(com/zejian/enumdemo/Day,s); &#125; //私有构造器 private Day(String s,int i)&#123; super(s,i); &#125; //前面定义的七种枚举实例 public static final Day MONDAY; public static final Day TUESDAY; public static final Day WEDNESDAY; public static final Day THURSDAY; public static final Day FRIDAY; public static final Day SATURDAY; public static final Day SUNDAY; private static final Day $VALUES[]; static&#123; //实例化枚举实例 MONDAY = new Day(&quot;MONDAY&quot;, 0); TUESDAY = new Day(&quot;TUESDAY&quot;, 1); WEDNESDAY = new Day(&quot;WEDNESDAY&quot;, 2); THURSDAY = new Day(&quot;THURSDAY&quot;, 3); FRIDAY = new Day(&quot;FRIDAY&quot;, 4); SATURDAY = new Day(&quot;SATURDAY&quot;, 5); SUNDAY = new Day(&quot;SUNDAY&quot;, 6); $VALUES = (new Day[] &#123; MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY &#125;); &#125;&#125; 枚举常见方法 常量在jdk1.5之前，我们定义常量都是：public static final…。有了枚举之后，就可以就把相关的常量分组到一个枚举类型里，而且提供了比常量更多的方法。 123public enum Color&#123; RED, GREEN, BLANK, YELLOW&#125; switchjdk1.6前的switch语句只支持int、char、enum，能让我们的代码可读性更强。 12345678910111213141516171819enum Signal&#123; GREEN, YELLOW, RED&#125;public class TrafficLight&#123; Signal color = Signal.RED; public void change()&#123; switch(color)&#123; case RED: color = Signal.GREEN; break; case YELLOW: color = Signal.RED; break; case GREEN: color = Signal.YELLOW; break; &#125; &#125;&#125; 向枚举中添加新方法如果打算自定义自己的方法，那么必须在enum实例序列的最后添加一个分号。而且要求 java必须先定义enum实例。123456789101112131415161718192021222324252627282930313233public enum Color&#123; RED(&quot;红色&quot;,1),GREEN(&quot;绿色&quot;,2),BLANK(&quot;白色&quot;,3),YELLOW(&quot;黄色&quot;,4); //成员变量 private String name; private int index; //构造方法 private Color(String name,int index)&#123; this.name = name; this.index = index; &#125; //普通方法 public static String getName(int index)&#123; for(Color c: Color.values)&#123; if(c.getIndex() == index)&#123; return c.name; &#125; &#125; return null; &#125; //get set方法 public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name = name; &#125; public int getIndex()&#123; return index; &#125; public void setIndex(int index)&#123; this.index = index; &#125;&#125; 覆盖枚举的方法下面给出一个覆盖toString()的例子：12345678910111213141516public enum Color&#123; RED(&quot;红色&quot;,1),GREEN(&quot;绿色&quot;,2),BLANK(&quot;白色&quot;,3),YELLOW(&quot;黄色&quot;,4); //成员变量 private String name; private int index; //构造方法 private Color(String name,int index)&#123; this.name = name; this.index = index; &#125; @Override public String toString()&#123; return this.index+&quot;_&quot;+this.name; &#125;&#125; 实现接口所有的枚举都继承自java.lang.Enum类。由于java不支持多继承，所以枚举类不能再继承其它类。123456789101112131415161718192021222324252627public interface Behaviour&#123; void print(); String getInfo();&#125;public enum Color implements Behaviour&#123; RED(&quot;红色&quot;,1),GREEN(&quot;绿色&quot;,2),BLANK(&quot;白色&quot;,3),YELLOW(&quot;黄色&quot;,4); //成员变量 private String name; private int index; //构造方法 private Color(String name,int index)&#123; this.name = name; this.index = index; &#125; //接口方法 @Override public void print()&#123; System.out.println(this.index+&quot; &quot;+this.name); &#125; @Override public String getInfo()&#123; return this.name; &#125;&#125; 使用接口组织枚举123456789public interface Food&#123; enum Coffee implments Food&#123; BLACK_COFFEE,DECAF_COFFEE,LATTE,CAPPUCCINO &#125; enum Dessert implements Food&#123; FRUIT,CAKE,GELATO &#125;&#125; 详情参考http://blog.csdn.net/javazejian/article/details/71333103。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的数组]]></title>
    <url>%2F2018%2F03%2F16%2F2018-03-14-Java%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组定义数组只是相同类型的、用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。定义一个数组，只需在类型名后加上一对空括号即可：1int[] a1; 方括号也可以配置标识符后面：1int a1[]; 编译器不允许指定数组的大小。a1只是数组的一个引用。存储空间的分配将有编译器负责，初始化数组：1int[] a1 = &#123;1,2,3,4,5&#125;; 1234567891011public class ArraysOfPrimitives&#123; public static void main(String[] args)&#123; int[] a1 = &#123;1,2,3,4,5&#125;; int[] a2; a2 = a1; for(int i=0;i&lt;a2.length;i++) a2[i] = a2[i]+1; for(int i = 0;i&lt;a1.length;i++) System.out.println(&quot;a1[&quot;+i+&quot;] = &quot; + a1[i]); &#125;&#125; 123456Output: a1[0] = 2 a1[1] = 3 a1[2] = 4 a1[3] = 5 a1[4] = 6 从下面可以看出引用a1和引用a2指向同一个数组。 数组声明1234String[] arr;int arr1[];String[] array = new String[5];int score[] = new int[3]; 初始化数组123456789//静态初始化int arr2[] = new int[]&#123;1,2,3,4,5&#125;;String[] array1 = &#123;&quot;马超&quot;,&quot;关羽&quot;,&quot;张飞&quot;,&quot;赵云&quot;,&quot;黄忠&quot;&#125;;String[] array2 = new String[]&#123;&quot;马超&quot;,&quot;关羽&quot;,&quot;张飞&quot;,&quot;赵云&quot;,&quot;黄忠&quot;&#125;;int score[] = new int[3];//动态初始化for(int i=0;i&lt;score.lenght;i++)&#123; score[i] = i+1;&#125; 查看数组长度1int length = array1.length; int数组转成String数组12int[] array3 = &#123;1,2,3,4&#125;;String arrStrings = Arrays.toString(array3); 数组中是否含有一个值12345String a=&quot;马超&quot;;String[] array1=&#123;&quot;马超&quot;,&quot;马云&quot;,&quot;关羽&quot;,&quot;刘备&quot;,&quot;张飞&quot;&#125;;if (Arrays.asList(array1).contains(a)) &#123; System.out.println(&quot;马超在这里&quot;);&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初始化顺序]]></title>
    <url>%2F2018%2F03%2F16%2F2018-03-14-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%85%88%E5%90%8E%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[在类的内部，变量定义的先后顺序决定了初始化的顺序。即使变量定义散布于方法定义之间，它们仍旧会在任何方法（包括构造器）被调用之前得到初始化。12345678910111213141516171819202122232425class Window&#123; Window(int marker)&#123; System.out.println(&quot;Window (&quot;+marker+&quot;)&quot;); &#125;&#125;class House&#123; Window w1 = new Window(1); House()&#123; System.out.println(&quot;House&quot;); w3 = new Window(33); &#125; Window w2 = new Window(2); void f()&#123; System.out.println(&quot;f()&quot;); &#125; Window w3 = new Window(3);&#125;public class OrderOfInitialization&#123; public static void main(String[] args)&#123; House h = new House(); h.f(); &#125;&#125; 123456Output: window(1) window(2) window(3) window(33) f() 静态数据的初始化总结对象的创建过程，假设有个名为Dog的类： 即使没有显示的使用static关键字，构造器实际上也是静态方法。因此，当首次创建类型为Dog的对象时（构造器可以看成静态方法），或者Dog类的静态方法/静态域首次被访问时，Java解释器必须查找类路径，以定位Dog.class文件。 然后载入Dog.class（这将创建一个Class对象），有关静态初始化的所有动作都会执行。因此，静态初始化只在Class对象首次加载的时候进行一次。 当用new Dog()创建对象的时候，首先将在堆上为Dog对象分配足够的存储空间。 这块存储空间会被清零，这就自动地将Dog对象中的所有基本数据类型都设置成了默认值（对数字来说是0，对布尔类型和字符型也相同），而引用则被设置成了null。 执行所有出现于字段定义处的初始化动作。 执行构造器。这可能会涉及很多动作，尤其是涉及继承的时候。执行静态块内的程序或者静态初始化的时间为：首次生成这个类的一个对象时或者首次访问属于那个类的静态数据成员时。非静态实例初始化 123456789101112131415161718192021222324252627282930313233class Mug&#123; Mug(int marker)&#123; System.out.println(&quot;Mug(&quot;+marker+&quot;)&quot;); &#125; void f(int marker)&#123; System.out.println(&quot;f(&quot;+marker+&quot;)&quot;); &#125;&#125;public class Mugs&#123; Mug mug1; Mug mug2; &#123; mug1= new Mug(1); mug2= new Mug(2); System.out.println(&quot;mug1 &amp; mug2 initialized&quot;); &#125; Mugs()&#123; System.out.println(&quot;Mugs()&quot;); &#125; Mugs(int i)&#123; System.out.println(&quot;Mugs(int)&quot;); &#125; public static void main(String[] args)&#123; System.out.println(&quot;Inside main()&quot;); new Mugs(); System.out.println(&quot;new Mugs() completed&quot;); new Mugs(1); System.out.println(&quot;new Mugs(1) completed&quot;); &#125;&#125; 123456789101112Output: Inside main() Mug(1) Mug(2) mug(1) &amp; mug(2) initialize Mugs() new Mugs() completed Mug(1) Mug(2) mug(1) &amp; mug(2) initialize Mugs(2) new Mugs(2) completed 从输出可以看出，无论调用哪个构造器，类中花括号{}内的代码都会执行一次，而且是在构造器之前执行的。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[局部变量和成员变量的初值]]></title>
    <url>%2F2018%2F03%2F16%2F2018-03-14-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Java尽力保证所有变量在使用前都能得到恰当的初始化。 类的成员变量如果类的成员变量是基本数据类型，则会被自动赋予一个初始值。12345678public class InitialValue&#123; static boolean b; static char c; static int i; public static void main(String[] args)&#123; System.out.println(&quot;b:&quot;+b+&quot; c:&quot;+c+&quot; i:&quot;+i); &#125;&#125; 局部变量对于方法的局部变量，Java会以编译时错误的形式要求给局部变量赋一个初值。1234void fun()&#123; int i; i++;//Error -- i not initialized&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java垃圾回收机制]]></title>
    <url>%2F2018%2F03%2F15%2F2018-03-15-Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[垃圾回收机制Java垃圾回收器负责回收无用对象占据的内存资源，所谓无用，就是指对象没有引用。因为对象是通过引用来操作的，所以如果对象没有引用就表示该对象已成为需要被清理的“垃圾”，需要释放其占用的内存。内存泄漏：不再使用的对象没有被回收，就是内存泄漏，在不涉及复杂数据结构的一般情况下，Java的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，我们有时也称为“对象游离”。 垃圾回收机制的意义Java语言中一个显著的特点就是引入了垃圾回收机制，使C++程序员最为头痛的问题迎刃而解，它使得Java程序员在编写程序时不再考虑其内存管理。由于有个垃圾回收机制，Java中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”。垃圾回收机制有效的防止了内存泄漏，有效的使用内存空间。 垃圾回收机制中的算法Java语言规范没有明确地说明JVM使用哪种垃圾回收算法，但是任何一种垃圾回收算法都要做两件事情：（1）发现无用对象；（2）回收被无用对象占用的内存空间，使该空间可以被程序再次使用。1.引用计数法（Reference Counting Collector）1.1 算法分析引用计数是垃圾收集器的早期策略。这种方法堆中每一个对象都有一个引用计数，当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a=b，则b引用的对象的计数加1），但当一个对象实例的引用超过了生命周期或被设置为一新值时，对象实例的引用计数减1。任何引用计数为0的对象实例可以被当做垃圾收集。当一个对象实例被当做垃圾收集时，它引用的任何对象的实例的引用计数减1。1.2 优缺点优点：引用计数收集器可以很快的执行，交织在程序运行中。对不能长时间打断程序运行的实时环境比较有利。缺点：无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样它们的引用计数永远不能为0。1.3 引用计数法无法解决循环引用问题，如：12345678910111213141516public class Main&#123; public static void main(String[] args)&#123; MyObject object1 = new MyObject(); MyObject object2 = new MyObject(); object1.object = object2; object2.object = object1; object1 = null; object2 = null; &#125;&#125;class MyObject&#123; public Object object = null;&#125; 最后面两句将object1和object2设置为null，也就是说object1和object2指向的对象已经不能再被访问了，但是它们互相引用对象，导致它们的引用计数器都不为0，那么垃圾收集器就永远不会回收它们。 tracing算法(Tracing Collector)或标记-清除算法(mark and sweep)2.1 根搜索算法根搜索算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个结点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用点，当所有的引用节点寻找完毕后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。Java中可作为GC ROOT的对象有 虚拟机栈中引用的对象（本地变脸表） 方法区中静态属性引用的变量 方法区中常量引用的对象 本地方法栈中引用的对象（Native对象）2.2 tracing算法的示意图2.3 标记-清除算法反洗标记-清除算法采用从根集合进行扫描，对存活的对象标记，标记完毕后再扫描整个空间中未被标记的对象，进行回收，如上图所示。标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，因为标记-清除算法直接回收不存活的对象，因此会造成内存碎片。 compacting算法或标记-整理算法标记-整理算法采用标记-清除算法一样的方式进行对象标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有存活的对象往左端空闲空间移动，并更新对应的指针。标记-清理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。在基于compacting算法的收集器的实现中，一般增加句柄和句柄表。 coping算法该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它开始时把对象分成一个对象面和多个空闲面，程序从对象面为对象分配空间，当对象满了，基于coping算法的垃圾收集就从根集中扫描活动对象，并将活动对象复制到空闲面（使得活动对象所占的内存之间没有空闲洞），这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。一种典型的基于coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象面和空闲区域面，在空闲区域面和对象面的切换过程中，程序暂停执行。 generating算法（Generational Collector）分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采用不同的回收算法，以便提高回收效率。年轻代(Young Generation) 所有新生成的对象首先是放在年轻代的。年轻代的目标就是尽可能快速收集掉那些生命周期短的对象。 新生代内存按照8:1:1的比例分成一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个survivor区（一般而言）。大部分对象在Eden区生成。回收时先将Eden区存活对象复制到一个survivor0区，然后清空Eden区，当这个survivor0区也存放满了时，则将Eden区和survivor0区存活对象复制到另一个survivor1区，然后清空Eden区和survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区是空的，如此往复。 survivor1区不足以存放Eden区和survivor0区的存活对象时，就将存活对象直接放到老年代。若是老年代也放满了就会触发一次Full GC，也就是新生代、老年代都进行回收。 新生代发生的GC也叫做Minor GC，Minor GC发生频率比较高（不一定等Eden区满了才才触发）。老年代 在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到老年代中。因此，可以认为老年代中存放的对象都是一些生命周期较长的对象。 内存比新生代也大很多（大概比例是1:2），当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。持久代用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。GC（垃圾收集器）新生代收集器使用的收集器：Serial、PradaNew、Parallel Scavenge老年代拉机器使用的收集器：Serial Old、Parallel Old、CMSSerial收集器（复制算法）新生代单线程收集器，标记和清理都是单线程，优点是简单高效。Serial Old收集器（标记-整理算法）老年代单线程收集器，serial收集器的老年代版本。ParNew收集器（停止-复制算法）新生代收集器，可以认为是serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现。Parallel Scavenge收集器（停止-复制算法）并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%，吞吐量=用户线程时间/（用户线程时间+GC线程时间）。适合后台应用对等交互相应要求不高的场景。Parallel Old收集器（停止-复制算法）Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先。CMS（Concurrent Mark Sweep）收集器（标记-清理算法）高并发、低停顿，追求最短GC回收停顿时间，CPU占用比较高，响应时间快，停顿时间段，多核CPU追求高响应时间的选择。GC执行机制由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Scavenge GC和Full GC。Scavenge GC一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。Full GC对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：1.年老代（Tenured）被写满2.持久代（Perm）被写满3.System.gc()被显示调用4.上一次GC之后Heap的各域分配策略动态变化Java有了GC同样会出现内存泄漏问题 静态集合类像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放，因为他们也将一直被Vector等应用着。1234567Static Vector v = new Vector(); for (int i = 1; i&lt;100; i++) &#123; Object o = new Object(); v.add(o); o = null; &#125; 在这个例子中，代码栈中存在Vector 对象的引用 v 和 Object 对象的引用 o 。在 For 循环中，我们不断的生成新的对象，然后将其添加到 Vector 对象中，之后将 o 引用置空。问题是当 o 引用被置空后，如果发生 GC，我们创建的 Object 对象是否能够被 GC 回收呢？答案是否定的。因为， GC 在跟踪代码栈中的引用时，会发现 v 引用，而继续往下跟踪，就会发现 v 引用指向的内存空间中又存在指向 Object 对象的引用。也就是说尽管o 引用已经被置空，但是 Object 对象仍然存在其他的引用，是可以被访问到的，所以 GC 无法将其释放掉。如果在此循环之后， Object 对象对程序已经没有任何作用，那么我们就认为此 Java 程序发生了内存泄漏。 各种连接，数据库连接，网络连接，IO连接等没有显示调用close关闭，不被GC回收导致内存泄露。 监听器的使用，在释放对象的同时没有相应删除监听器的时候也可能导致内存泄露。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[finalize()用法]]></title>
    <url>%2F2018%2F03%2F15%2F2018-03-15-finalize()%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[垃圾回收只与内存有关Java垃圾回收器负责回收无用对象占据的内存资源。使用垃圾回收器的唯一原因是为了回收程序不再使用的内存。所以对于与垃圾回收有关的任何行为来说，尤其是finalize()方法，它们也必须内存及回收有关。特殊情况：假定你的对象（并非使用new）获得了一块特殊的内存区域，由于垃圾回收器只知道释放那些经由new分配的内存，所以它不知道如何释放该对象的“特殊”内存。解决办法：Java允许在类中定义一个finalize()方法释放内存。finalize()工作原理：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法，并且在下一次垃圾回收动作发生时，才会真正回收对象所占用的内存。所以要是你打算用finalize()，就能在垃圾回收时刻做一些重要的清理工作。 注意： 只要程序没有濒临存储空间用完的那一刻，对象占用的空间就不会被释放；如果程序执行结束，并且垃圾回收器一直没有释放你创建的任何对象的存储空间，则随着程序的退出，那些资源也会全部还给操作系统。这个策略是正确的，因为垃圾回收本身也有开销，要是不适用它，就不用支付这部分开销了； 垃圾回不是一定会执行，不是程序员可以控制的； finalize()是否执行也是不可控； finalize()是Object中的方法，源码如下，只是一个空方法 123protected void finalize() throws Throwable&#123;&#125; finalize()方法会在对象被垃圾回收之前被垃圾回收器调用一次，这是Java语言的一种机制； finalize()方法在任何对象上最多只会被垃圾回收器调用一次； 垃圾回收器无法保证无用对象能被回收，因此，finalize()方法也无法保证运行，建议不要重写finalize()方法，即使重写，也不要在finali()里写关键代码。强制的垃圾回收System.gc() 实际上这里的强制，是程序员的意愿、建议，什么时候执行是JVM的垃圾回收说了算。 调用垃圾回收也不一定能保证未使用的对象一定能从内存中删除，唯一能保证的是当内存极少的情况下，垃圾回收器在程序抛出OutofMemaryException之前运行一次。 String与垃圾回收对于String，存在一个字符串池，这个不属于本文讨论的范围，字符串池中的垃圾回收，算法和这里所讨论的垃圾回收完全是两码事。但是不得不说的是，字符串的胡乱拼接，往往导致性能急剧下降，尤其是在庞大的循环语句中，拼接字符串就是在让程序慢性自杀。这也是很多Java程序员容易犯的毛病。字符串既然是池，就是为了缓冲，为了有更高的命中率，因此垃圾回收的频率也许会比JVM对象垃圾回收器要低很多。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this关键字的用法]]></title>
    <url>%2F2018%2F03%2F14%2F2018-03-14-this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[this关键字只能在方法内使用，表示“调用方法的那个对象”的引用。this的用法和其他对象引用并无不同。1234567891011121314class Banana&#123; void peel(int i)&#123; /*...*/ &#125;&#125;public class BananaPeel&#123; public static void main(String[] args)&#123; Banana a = new Banana(), b = new Banana(); a.peel(1); b.peel(2); &#125;&#125; 如果只有一个peel()方法，它如何知道是被a还是被b调用的呢？编译器实际做了一些幕后工作，它暗自把“所操作对象的引用”作为第一个参数传递给peel()。所以上述两个方法的调用变成了这样：12Banana.peel(a,1);Banana.peel(b,2); 这是内部的表示形式。 this关键字主要有以下应用调用成员变量123456Public Class Student &#123; String name; //定义一个成员变量name private void SetName(String name) &#123; //定义一个参数(局部变量)name this.name=name; //将局部变量的值传递给成员变量 &#125; &#125; 在构造函数中调用构造函数1234567public class Student &#123; //定义一个类，类的名字为student。 public Student() &#123; //定义一个方法，名字与类相同故为构造方法 this(“Hello!”); &#125; public Student(String name) &#123; //定义一个带形式参数的构造方法 &#125; &#125; 值得注意的是： 1. 在构造调用另一个构造函数，调用动作必须置于最起始的位置。 2. 不能在构造函数以外的任何函数内调用构造函数。 3. 在一个构造函数内只能调用一个构造函数。 返回对象的引用 this关键字除了可以引用变量或者成员方法之外，还有一个重大的作用就是返回类的引用。如在代码中，可以使用return this，来返回某个类的引用。此时这个this关键字就代表类的名称。如代码在上面student类中，那么代码代表的含义就是return student。可见，这个this关键字除了可以引用变量或者成员方法之外，还可以作为类的返回值，这才是this关键字最引人注意的地方。 static与this static就是没有this的方法，在static方法的内部不能调用非静态方法，但是非静态方法可以调用静态方法。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java类构造器]]></title>
    <url>%2F2018%2F03%2F14%2F2018-03-14-Java%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Java的类构造器必须是public吗 Java的类构造器不是必须用public修饰，也可以用private、protected等修饰，要看你想控制这个类被实例化的范围。 默认构造器一定是public的吗 不一定，要看你的类是什么修饰的，如果你的类是public的，则默认构造器是public，如果你的类是private，则默认构造器是private。 构造器前不一定要加public、private等修饰，也可以什么都不加，比如：123456789class Test&#123; Test()&#123; &#125; Test(String msg)&#123; System.out.println(&quot;msg:&quot;+msg); &#125;&#125; 无参构造器与有参构造器 如果没有定义构造器，编译器会自动的帮我们创建一个无参构造器； 如果我们定义了一个构造器（无论有参还是无参），编译器就不会再自动创建默认的构造器； 如果定义了有参构造器而没有显示的写出无参构造器，当尝试调用无参构造器实例化对象时，此时编译器会报错，因为找不到无参构造器。所以，如果定义了有参构造器，一般要显示的写出无参构造器，以防不能通过无参构造器实例化对象。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[switch用法]]></title>
    <url>%2F2018%2F03%2F14%2F2018-03-14-switch%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[switch简介在jdk1.7之前，switch的比较范围仅限于（int、short、byte、char）之间，Java虚拟机和字节代码在这个层次上，只支持switch语句中使用与整数类型兼容的类型。在jdk1.7后switch支持字符串比较的功能。基本语法：12345678910111213141516switch(integral-selector)&#123; case integral-value1 : statement; break; case integral-value2 : statement; break; case integral-value3 : statement; break; case integral-value4 : statement; break; default: statement; &#125; integral-selector(整数选择因子) integral-value(整数值) break是可选的，如果没有break则语句会继续执行，直到遇到break或运行到结尾 default表示在没有匹配的情况下默认执行的语句，因为是程序已经执行到最后，所以不需要break，如果添加break也可以，但是break不起作用。 switch和枚举结合使用创建一个枚举类型123public enum Season&#123; Spring,Summer,Autumn,Winter&#125; 1234567891011121314151617181920212223242526272829303132333435public class MainTest &#123; Season season; public MainTest(Season season) &#123; this.season = season; &#125; public void describe() &#123; switch (season) &#123; case Spring : System.out.println(&quot;Spring&quot;); break; case Summer : System.out.println(&quot;Summer&quot;); break; case Autumn : System.out.println(&quot;Autumn&quot;); break; case Winter : System.out.println(&quot;Winter&quot;); break; default: System.out.println(&quot;can not find any value&quot;); &#125; &#125; public static void main(String[] args) &#123; MainTest spring = new MainTest(Season.Spring); MainTest summer = new MainTest(Season.Summer); spring.describe(); summer.describe(); &#125;&#125; switch与String结合使用12345678910111213141516switch (season) &#123; case &quot;a&quot; : System.out.println(&quot;Spring&quot;); break; case &quot;b&quot; : System.out.println(&quot;Summer&quot;); break; case &quot;c&quot; : System.out.println(&quot;Autumn&quot;); break; case &quot;d&quot; : System.out.println(&quot;Winter&quot;); break; default: System.out.println(&quot;can not find any value&quot;); &#125; switch使用String的内部实现12345678910111213141516/** * Java Program to demonstrate how string in switch functionality is implemented in * Java SE 7 release. */public class StringInSwitchCase &#123; public static void main(String[] args) &#123; String mode = args[0]; switch (mode) &#123; case &quot;ACTIVE&quot;: System.out.println(&quot;Application is running on Active mode&quot;); break; case &quot;PASSIVE&quot;: System.out.println(&quot;Application is running on Passive mode&quot;); break; case &quot;SAFE&quot;: System.out.println(&quot;Application is running on Safe mode&quot;); &#125; &#125; &#125; 反编译后：123456789101112131415161718192021222324252627/** * Reverse Engineered code to show how String in Switch works in Java. */import java.io.PrintStream; public class StringInSwitchCase&#123; public StringInSwitchCase() &#123; &#125; public static void main(string args[]) &#123; String mode = args[0]; String s; switch ((s = mode).hashCode()) &#123; default: break; case -74056953: if (s.equals(&quot;PASSIVE&quot;)) &#123; System.out.println(&quot;Application is running on Passive mode&quot;); &#125; break; case 2537357: if (s.equals(&quot;SAFE&quot;)) &#123; System.out.println(&quot;Application is running on Safe mode&quot;); &#125; break; case 1925346054: if (s.equals(&quot;ACTIVE&quot;)) &#123; System.out.println(&quot;Application is running on Active mode&quot;); &#125; break; &#125; &#125; &#125; 从反编译的代码可以看出字符串的switch是通过equals()和hashCode()方法来实现的，switch内部依旧使用的是整型比较。hashCode()的方法返回的是int，而不是long。结论 switch中使用整型常量和枚举效率相对高一些； switch中的String比较使用的是字符串产生的hashCode来equals()比较; 尽量使用整型常量和枚举。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的标签]]></title>
    <url>%2F2018%2F03%2F14%2F2018-03-14-Java%E4%B8%AD%E7%9A%84%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[标签简介标签是后面跟有冒号的标识符，就像下面这样：label1:在Java中，标签起作用的唯一的地方刚好是在迭代语句之前。“刚好之前”的意思表明，在标签和迭代之间置入任何语句都不好。而在迭代之前设置标签的唯一理由是：我们希望在其中嵌入另一个迭代或者一个开关。这是由于break和continue关键字只会中断当前循环，但若同标签一同使用，就会中断循环，直到标签所在的地方。 示例解析12345678910111213label1:outer-iteration&#123; inner-iteration&#123; //... break;//(1) //... continue;//(2) //... continue label1;//(3) //... break label1;//(4) &#125;&#125; 在（1）中，break中断内部迭代，回到外部迭代。在（2）中，continue使执行点回到内部迭代的起始处。在（3）中，continue label1同时中断内部迭代和外部迭代，直接转到label1处；随后，它实际上是继续迭代过程，但却从外部迭代开始。在（4）中，break label1也会中断所有迭代，回到label1处，但并不重新进入迭代，也就是说，它实际是完全终止了两个迭代。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[return和break及continue]]></title>
    <url>%2F2018%2F03%2F14%2F2018-03-14-return%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[returnreturn关键字有两方面的作用： 指定一个方法返回什么值，假设它没有void返回值； 会导致当前方法退出，并返回那个值。如果在返回void的方法中没有return语句，那么在该方法的结尾处会有一个隐式的return，因此在方法中并非总是必须要有一个return语句。 break和continuebreak用于强行退出循环，不执行循环中剩余的语句。而continue则停止当前迭代，然后退回循环起始处，开始下一次迭代。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[短路与和与的区别]]></title>
    <url>%2F2018%2F03%2F13%2F2018-03-13-%E9%80%BB%E8%BE%91%E4%B8%8E%E5%92%8C%E4%B8%8E%E7%9A%84%E5%8C%BA%E5%88%AB%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[区别1234* &amp;&amp;（短路与）只要有一个满足条件，后面的条件就不再判断* &amp;（与）对所有条件都进行判断* ||（短路或）只要有一个满足条件，后面的条件就不再判断* |（或）对所有条件都进行判断 &amp;&amp;和&amp;例子1234567public class Test&#123; public static void main(String[] args)&#123; if(100!=100 &amp; 100/0==0)&#123; System.out.println(&quot;Hello&quot;); &#125; &#125;&#125; 123Output: Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero at com.test.cn.Test001.main(Test001.java:32) 将&amp;修改为&amp;&amp;：1234567public class Test&#123; public static void main(String[] args)&#123; if(100!=100 &amp;&amp; 100/0==0)&#123; System.out.println(&quot;Hello&quot;); &#125; &#125;&#125; 12Output: Hello ||和|例子1234567public class Test&#123; public static void main(String[] args)&#123; if(100==100 | 100/0==0)&#123; System.out.println(&quot;Hello&quot;); &#125; &#125;&#125; 123Output: Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero at com.test.cn.Test001.main(Test001.java:32) 将|修改为||：1234567public class Test&#123; public static void main(String[] args)&#123; if(100==100 || 100/0==0)&#123; System.out.println(&quot;Hello&quot;); &#125; &#125;&#125; 12Output: Hello]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Random与Math.random()]]></title>
    <url>%2F2018%2F03%2F13%2F2018-03-13-Random%E7%B1%BB%E4%B8%8EMath.random()%2F</url>
    <content type="text"><![CDATA[Random此类的实例用于生成伪随机数，如果用相同的种子创建两个Random实例，则对每个实例进行相同的方法调用序列，它们将产生并返回相同的数字序列。12345678public class test&#123; public static void main(String[] args)&#123; Random random = new Random(); for(int i=1;i&lt;4;i++)&#123; System.out.println(random.nextInt()); &#125; &#125;&#125; 上面的代码每次运行都会产生一组不同上一组的三个随机数。 12345678public class test&#123; public static void main(String[] args)&#123; Random random = new Random(47); for(int i=1;i&lt;4;i++)&#123; System.out.println(random.nextInt()); &#125; &#125;&#125; 上面的代码给Random设置了种子47，每次运行产生的随机数和上次运行产生的随机数完全相同，即相同的种子每次运行会产生一样的随机数。这是因为种子被确定了，在Java中，随机数的产生取决于种子，随机数和种子之间的关系遵从以下两个规则： 种子不同，产生不同的随机数 种子相同，即使实例不同也会产生相同的随机数看完上面两个例子，我们发现问题就出在有参构造上，Random默认的种子（无参构造）是System.nanoTime()的返回值（JDK1.5之前的默认种子是System.currentTimeMillis()的返回值），注意这个值是距离某一个固定时间点的纳秒数，不同的操作系统和硬件有不同的时间点，也就是说不同的操作系统其纳秒值是不同的，而同一个操作系统纳秒值也会不同，随机数自然就不同了。（顺便说一下，System.nanoTime()不能用于计算日期，那是因为“固定”的时间点是不确定的，纳秒值可能是负值，这点与System.currentTime()不同）。所以如果不是必须的，不要Random的种子。12Random random = new Random();int num = random.nextInt(100); 上述代码将产生[0,100)的整数。 ###Math.random()Math.random()返回带正号的返回值，该值大于等于0小于1，即[0,1)。返回值是一个伪随机选择的数，在该范围内（近似）均匀分布。Math.random()是线程安全的，它在内部调用java.util.Random()。12int num=(int)(Math.random()*n); //返回大于等于0小于n之间的随机数 int num0=m+(int)(Matn.randon()*n); //返回大于等于m小于m+n（不包括m+n）之间的随机数 总结 Random.nextInt()比Math.random()效率高一点]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[static关键字(2)]]></title>
    <url>%2F2018%2F03%2F13%2F2018-03-13-static%E5%85%B3%E9%94%AE%E5%AD%97(2)%2F</url>
    <content type="text"><![CDATA[对象的初始化过程，以下为例：12345678910111213141516171819202122232425262728293031package com.dotgua.study;class Book&#123; public Book(String msg)&#123; System.out.println(msg); &#125;&#125;public class Person&#123; Book book1 = new Book(&quot;book1成员变量初始化&quot;); static Book book2 = new Book(&quot;static成员book2成员变量初始化&quot;); public Person(String msg)&#123; System.out.println(msg); &#125; Book book3 = new Book(&quot;book3成员变量初始化&quot;); static Book book4 = new Book(&quot;static成员book4成员变量初始化&quot;); public static void main(String[] args)&#123; Person p1 = new Person(&quot;p1初始化&quot;); &#125;&#125;/**Output *static成员book2成员变量初始化 *static成员book4成员变量初始化 *book1成员变量初始化 *book3成员变量初始化 *p1初始化 */ 从上面的例子可以看出，当类初始化的时候，static修饰的成员最先被初始化，随后是普通成员，最后调用Person的构造方法完成初始化。也就是说，在创建对象时，static修饰的成员会首先被初始化，而且我们还可以看到，如果有多个static修饰的成员时，那么会按照它们的先后位置进行初始化。 实际上，static修饰的成员可以更早的进行初始化123456789101112131415161718192021222324252627282930313233343536373839package com.dotgua.study;class Book&#123; public Book(String msg)&#123; System.out.println(msg); &#125;&#125;public class Person&#123; Book book1 = new Book(&quot;book1成员变量初始化&quot;); static Book book2 = new Book(&quot;static成员book2成员变量初始化&quot;); public Person(String msg)&#123; System.out.println(msg); &#125; Book book3 = new Book(&quot;book3成员变量初始化&quot;); static Book book4 = new Book(&quot;static成员book4成员变量初始化&quot;); public static void funStatic()&#123; System.out.println(&quot;static修饰的funStatic方法&quot;); &#125; public static void main(String[] args)&#123; Person.funStatic(); System.out.println(&quot;********&quot;); Person p1 = new Person(&quot;p1初始化&quot;); &#125;&#125;/**Output *static成员book2成员变量初始化 *static成员book4成员变量初始化 *static修饰的funStatic方法 ********** *book1成员变量初始化 *book3成员变量初始化 *p1初始化 */ 在上面的例子我们可以发现两个有意思的地方，第一个是当我们没有创建对象，而是通过类去调用方法时，尽管该方法没有使用任何的类成员，类成员还是在静态方法调用之前初始化了，这说明，当我们第一次去使用一个类时，就会触发类成员初始化；第二个是，当我们使用了类方法，完成类成员的初始化后，再new该类的对象时，static修饰的类成员没有再次初始化，这说明，static修饰的类成员，在程序运行过程中，只需要初始化一次即可，不会进行多次的初始化。 当我们初始化static修饰的成员时，可以将它们同意放在static块内1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.dotgua.study;class Book&#123; public Book(String msg)&#123; System.out.println(msg); &#125;&#125;public class Person&#123; Book book1 = new Book(&quot;book1成员变量初始化&quot;); static Book book2; static&#123; book2 = new Book(&quot;static成员book2成员变量初始化&quot;); book4 = new Book(&quot;static成员book4成员变量初始化&quot;); &#125; public Person(String msg)&#123; System.out.println(msg); &#125; Book book3 = new Book(&quot;book3成员变量初始化&quot;); static Book book4; public static void funStatic()&#123; System.out.println(&quot;static修饰的funStatic方法&quot;); &#125; public static void main(String[] args)&#123; Person.funStatic(); System.out.println(&quot;********&quot;); Person p1 = new Person(&quot;p1初始化&quot;); &#125;&#125;/**Output *static成员book2成员变量初始化 *static成员book4成员变量初始化 *static修饰的funStatic方法 ********** *book1成员变量初始化 *book3成员变量初始化 *p1初始化 */]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[static关键字(1)]]></title>
    <url>%2F2018%2F03%2F12%2F2018-03-12-static%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[static应用场景通常来说，当创建类时，就是用类来形容一个事物的外观与行为。除非用new来创建这个类的对象，否则并未获取任何对象。执行new来创建对象，数据存储空间才被分配，其方法才供外界调用。有两种情形上述方法是无法解决的。一种情形是，指向为某特定域分配单一存储空间，而不去考虑究竟要创建多少个对象，甚至根本就不创建任何对象。另一种情形是，希望某个方法不与包含它的类的任何对象相关联，也就是说不创建任何对象也能调用该方法。static可以满足这两方面的要求。当生命一个事物是static时，就意味着这个域或者方法不会与包含它的类的任何对象实例关联在一起。即可以直接通过类来调用该域或方法。static关键字不能应用于局部变量。 详细介绍Java中的static关键字主要是用来做内存管理的。理解了这句话才能比较深入地理解static。static可以修饰： 变量（class variable） 方法（class method） 代码块（block） 内部类（nested class） 静态导包凡是被static修饰的这四种元素，都属于class的元素，即类的，而不是类的实例（即对象）的。(1) 静态变量在声明变量的时候加上static，该变量即是静态变量。 什么时候该用static来修饰变量呢？该变量被该类的所有实例所共享。 静态变量在类被加载的时候初始化，且仅分配一次内存。这样做的好处就是内存利用率高，看看下面的demo：12345class Student&#123; int stuNo; String name; String college = &quot;ITS&quot;;&#125; 假设这个学校有50000000000个学生，那么当每一个学生被创建的时候，都会初始化学号、姓名、学校，每个学生都有自己的学号、姓名，这样做没问题；但是每个学生的college字段都相同，如果每次都声明一次的话，是比较耗内存的。这里的college变量是被该类的所有实例所共享的，因此可以将它声明为static的。1234567891011121314151617class Student8&#123; int rollno; String name; static String college = &quot;ITS&quot;; void display()&#123; System.out.println(rollno+&quot; &quot;+name+&quot; &quot;+college); &#125; public static void main(String args[])&#123; Student8 s1 = new Student8(111,&quot;Karan&quot;); Student8 s2 = new Student8(222,&quot;Aryan&quot;); s1.display(); s2.display(); &#125;&#125; 123Output: 111 Karan ITS 222 Aryan ITS 看下实际内存分布情况： 再看一下下面这个例子：Counter类中声明了一个count变量，在构造函数中对其进行++操作，因为实例变量在创建对象的时候分配内存，所以每一个对象都有一份自己的count副本，每个对象对各自的count的++操作不会反映到其它对象上。12345678910111213class Counter&#123; int count = 0; Counter()&#123; count++; System.out.println(count); &#125; public static void main(String[] args)&#123; Counter c1 = new Counter(); Counter c2 = new Counter(); Counter c3 = new Counter(); &#125;&#125; 1234output: 1 1 1 因为静态变量仅仅在加载的时候分配一次内存，所以如果将count修饰为static，那么该类的所有对象都共享该静态变量，每一个对象对count的操作都会反映到其它对象上。12345678910111213class Counter2&#123; static int count = 0; Counter2()&#123; count++; System.out.println(count); &#125; public static void main(String[] args)&#123; Counter2 c1 = new Counter2(); Counter2 c2 = new Counter2(); Counter2 c3 = new Counter2(); &#125;&#125; 1234output: 1 2 3 (2)静态方法在声明方法的时候加上static关键字，即静态方法： 静态方法属于类而不属于对象； 静态方法的调用可以直接通过类名调用，而不需要创建类的对象； 静态方法可以修改静态变量，而非静态方法不可； 静态方法不能操作非静态变量，也不能调用非静态方法（可以这样理解，静态方法属于类，直接通过类名就可以调用，而此时可能没有任何实例，更谈不上操作实例变量和实例方法）； 静态方法不能使用this和super关键字。（道理同上）例子：123456class A&#123; int a = 40;//non static public static void mian(String[] args)&#123; System.out.println(a); &#125;&#125; 12Output: Compile Time error 为什么Java的main方法是static的？ 为了使在调用main方法前不创建任何对象。(3)静态代码块静态代码块的作用： 用来初始化静态变量； 在类加载时，在执行main方法之前执行相关操作。例子：12345678class A2&#123; static&#123; System.out.println(&quot;static block is invoked!&quot;); &#125; public static void main(String[] args)&#123; System.out.println(&quot;Hello,main!&quot;); &#125;&#125; 123Output: static block is invoked! Hello,main! Q:没有main方法的程序可以执行吗？ A:可以，在jdk1.7之前执行如下代码是可以的：123456class A3&#123; static&#123; System.out.println(&quot;static block is invoked!&quot;); System.exit(0); &#125;&#125; 12Output: static block is invoked! 但是在jdk1.7之后会报如下错误：123Output: Error:Main method not found in class A3,please define the main method as: public static void main(String[] args) (4)静态内部类被static修饰的类，并处于某个类的内部。 它可以访问外部类的静态成员，包括private成员； 它不能访问外部类的非静态成员。那么为什么要用静态类呢？看下面的例子：123456789101112class TestOuter1&#123; static int data = 30; static class Inner&#123; void msg()&#123; System.out.println(&quot;data is:&quot;+data); &#125; &#125; public static void main(String[] args)&#123; TestOuter1.Inner obj = new TestOuter1.Inner(); obj.msg(); &#125;&#125; 12Output: data is 30 main方法中创建了一个静态内部类的实例，并且调用了msg()方法。但是这里并没有创建外部类的实例，因为这里的Inner是static的，并且可以访问外部类的static成员。如果把Inner之前的static去掉，那么要这么写代码：1TestOuter1.Inner obj = new TestOuter1().new Inner(); 需要先创建一个外部类的实例，然后才能创建内部类的实例。静态内部类不仅高效利用内存，而且使得代码简洁。下面是静态内部类编译后的样子：1234567import java.io.PrintStream;static class TestOuter1$Inner&#123; TestOuter1$Inner()&#123;&#125; void msg()&#123; System.out.println(new StringBuilder().append(&quot;data is &quot;).append(TestOuter1.data).toString()); &#125;&#125; 上例中，如果msg()方法也是静态的，那么内部类的实例也不需要创建了：1234567891011class TestOuter1&#123; static int data = 30; static class Inner&#123; static void msg()&#123; System.out.println(&quot;data is:&quot;+data); &#125; &#125; public static void main(String[] args)&#123; TestOuter1.Inner.msg(); &#125;&#125; (5)静态导包相比较于上面的用途，这种用途知道的人就比较少了，但它实际上很简单，而且在调用类方法时更方便。例子：PrintHelper.java文件1234567package com.dotgua.study;public class PrintHelper&#123; public static void pring(Object obj)&#123; System.out.println(0); &#125;&#125; App.java文件1234567import static com.dotgua.study.PrintHelper.*;public class App&#123; public static void main(String[] args)&#123; print(&quot;Hello,world!&quot;); &#125;&#125; 12Output: Hello,world!]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中值传递与引用传递]]></title>
    <url>%2F2018%2F03%2F12%2F2018-03-12-Java%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[基本类型和引用在内存中的存储Java中基本数据类型和对象的引用都存储在堆栈中，堆栈的优势是存取速度快，仅次于寄存器，堆栈数据可以共享；缺点是存储在堆栈中的数据大小与生命周期必须是确定的，缺乏灵活性。堆栈中有一个很重要的特性是，堆栈中的数据可以共享假设我们同时定义：12int a = 3; int b = 3; 编译器先处理int a = 3;首先会在堆栈中创建一个变量为a的引用，然后查找堆栈中是否有3这个值，如果没有找到，就将3存放起来，然后将a指向3。接着处理int b = 3;在创建完b的引用变量后，因为在堆栈中已经存在3这个值，便将b直接指向3。这样就出现了a和b同时指向3的情况。这时再令a = 4;那么编译器会重新搜索堆栈中是否存在4这个值，如果没有，则将4放进来，并令a指向4；如果已经有了，则直接将a指向这个地址。因此a的值改变不会影响b的值。要注意这种数据的共享与两个对象的引用同时指向一个对象的这种共享不同，因为这种修改a的值不会影响到b，它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用量。String是一个特殊的包装类数据，可以用：12String str = new String(&quot;abc&quot;);String str = &quot;abc&quot;; 两种形式创建，第一种是用new来创建对象的，存放在堆中，每调用一次就会创建一个新的对象。而第二种是先在栈中创建一个对String类的对象引用变量str，然后在栈中查找有没有存放”abc”，如果没有，则将”abc”存放进栈，并令str指向”abc”；如果已经有”abc”，则直接令str指向”abc”。比较类里面的值是否想等用equals()，当测试两个包装类的引用是否指向同一个对象时，用==，示例：123String str1 = &quot;abc&quot;;String str2 = &quot;abc&quot;;System.out.println(str1 == str2); 12Output: true 可以看出str1和str2指向同一个对象。123String str1 = new String(&quot;abc&quot;);String str2 = new String(&quot;abc&quot;);System.out.println(str1 == str2); 12Output: false new的方式是生成不同的对象，每次生成一个。 搞清楚基本类型和引用类型的不同之处12int num = 10;String str = &quot;hello&quot;; 如图所示，num是基本类型，值就保存在变量中。而str是引用类型，变量中保存的只是实际对象的地址。一般称这种变量为引用，引用指向实际对象，实际对象中保存着内容。 搞清楚赋值运算符（=）的作用12num = 20;str = &quot;java&quot;; 对于基本类型num，赋值运算符会直接改变变量的值，原来的值被覆盖掉。对于引用类型str，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。但原来的对象不会被改变，如上图所示，”helo”，字符串没有被改变。（没有被任何引用指向的对象时垃圾，会被垃圾回收器回收） 调用方法时发生了什么？参数传递基本上就是赋值操作12345678910111213141516171819202122232425第一个例子：基本类型void foo(int value)&#123; value = 100;&#125;foo(num);//num没有被改变第二个例子：没有提供改变自身方法的引用类型void foo(String text)&#123; text = &quot;windows&quot;;&#125;foo(str);//str也没有被改变第三个例子：提供了改变自身方法的引用类型StringBuilder sb = new StringBuilder(&quot;iphone&quot;);void foo(StringBuilder builder)&#123; builder.append(&quot;X&quot;);&#125;foo(sb);//sb被改变了，变成了iPhone X第四个例子：提供了改变自身方法的引用类型，但是不适用，而是使用赋值运算符StringBuilder sb = new StringBuilder(&quot;iphone&quot;);void foo(StringBuilder builer)&#123; builder = new StringBuilder(&quot;ipad&quot;);&#125;foo(sb);//sb没有被改变，还是&quot;iphone&quot; 第三个例子的解释图：builder.append(“4”)之后 下面是第四个例子的解释：builder = new StringBuilder(“ipad”);之后]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的基本数据类型]]></title>
    <url>%2F2018%2F03%2F12%2F2018-03-12-Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Java中的数据类型 基本数据类型Java的基本数据类型存储在堆栈中。 基本类型默认值： 高精度数字Java提供了两个用于高精度计算的类：BigInteger和BigDecimal。虽然它们大体属于包装器类的范畴，但是二者都没有对应的基本类型。特点：速度慢，以速度换取精度。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java程序运行时的内存分配]]></title>
    <url>%2F2018%2F03%2F12%2F2018-03-12-Java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[Java程序内存分配 Java程序运行时有5个地方存储数据。 寄存器(register)这是最快的存储器，位于处理器内部。但是寄存器的数量极其有限，所以寄存器根据需求进行分配。不能对其进行直接控制，也不能在程序中感受到寄存器存在的任何迹象。C和C++允许向编译器建议寄存器的分配方式。 堆栈(stack)位于通用RAM（随机访问存储器）中，通过堆栈指针可以从处理器那里获得支持。堆栈指针向下移动，则分配新的内存；若堆栈指针向上移动，则释放那些内存。这是一种快速有效的分配方式，仅次于寄存器。Java系统必须知道存储在堆栈内的所有项的确切生命周期，以便上下移动堆栈指针。Java对象的引用存储在堆栈内，Java对象不存储在堆栈内。 堆(heap)一种通用的内存池，也位于RAM区，用于存放所有的Java对象。堆不同于堆栈的好处是：编译器不需要知道存储的数据在堆里存活多长时间。因此，在堆里分配存储有很大的灵活性。当需要一个对象时，只需用new写一行简单的代码，当执行这段代码时，会自动在堆里进行存储分配。当然，堆这种灵活性要付出相应的代价：用堆进行存储分配和清理可能比用堆栈进行存储分配需要更多的时间。 静态存储(static storage)这里的“静态”是指“在固定的位置”。静态存储里存放程序运行时一直存在的数据。你可以用static标识一个对象的特定元素是静态的，但Java对象本身从来不会存放在静态存储区。 常量存储(constant storage)常量值通常放在程序代码内部，这样做是安全的，因为它们永远不会被改变。有时，在嵌入式系统中，常量本身会和其它部分隔离开，所以在这种情况下，可以选择将其放在ROM（只读存储器）中。 非RAM存储()如果数据完全存活于程序之外，那么他们可以不受程序的任何控制，在程序没有运行时也可以存在。其中两个基本的例子是流对象和持久化对象。在流对象中，对象转化为字节流，通常被发送给另一台机器。在“持久化对象”中，对象被存放于磁盘上，因此，即使程序终止，它们仍可以保持自己的状态。这种存储方式的技巧在于：把对象转化成可以存放在其它媒介上的事物，在需要时，可以恢复为常规、基于RAM的对象。Java提供了对轻量级持久化的支持，而对于JDBC和Hibernate这样的机制提供了更加复杂的对在数据库中存储和读取对象信息的支持。 堆与堆栈 它们的存取数据对比如下： 寄存器 &gt; 堆栈 &gt; 堆 &gt; 其它 堆：堆是heap，是所谓的动态内存，其中的内存在不需要的时候可以回收，以分配给新的内存请求，其内存中的数据是无序的，即先分配的内存和后分配的内存在位置上没有必然联系，释放时也没有先后顺序。一般由使用者自由分配，malloc分配的就是堆，需要手动释放。 堆栈：就是stack。实际上是一个只有出入口的队列，即后进先出（FirstInLastOut），先分配的内存必定后释放。一般由系统自动分配，存放函数的参数值、局部变量，自动清除。堆是全局的，堆栈是每个函数进入的时候分一小块，函数返回时就释放了，静态和全局变量、new得到的对象都放在堆中，局部变量放在堆栈中，所以函数返回，局部变量就全没了。其实在实际应用中，堆栈多用来存储方法的调用，而堆用于对象的存储。Java中的基本类型需要特殊对待。因为在Java中通过new创建的对象存储在堆中，所以用new来创建一个小的、简单的变量，如基本类型等往往不是有效的。因此，在Java中对于这些类型，采取了和C、C++一样的策略，也就是说不用new来创建，而是创建一个并非引用的自动变量，这个变量拥有它的值，并置于堆栈中，因此更高效。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法总结]]></title>
    <url>%2F2018%2F03%2F11%2F2018-03-11-Markdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[什么是Markdown Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，他可以使普通文本内容具有一定格式。 Markdown是一种轻量级标记语言，让写作者专注于写作而不用关注格式。 Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此很多人用它写博客。 注意事项 1.编写的文件后缀是md； 2.标题符号#和编写的内容之间要留空格，比如”## 标题内容”，中间有一个空格。 语法 标题Markdown一共有6级标题，就相当于HTML中的H1,H2…H6，在Markdown中在文字前面加1-6个（#），然后再加上一个空格，以此表示是几级标题。 12345678910111213141516 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 ``` 显示效果： # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题2. 斜体 在文字首尾分别加上一个星号即可。 这里会显示为斜体 1234 显示效果： *这里显示为斜体* 3. 粗体 字体加粗只需在文字首尾分别加上两个星号 这里会显示粗体 1234567891011 显示效果： **这里会显示粗体**4. 删除线 在文字首尾分别上两个波浪线符好 ``` ~~这里的文字会被无情的删除掉~~ ``` 显示效果： ~~这里的文字会被无情的删除掉~~5. 换行 一段文字要换行只需在行末尾加上两个空格即可 这是第一行这是第二行在第一行末尾有两个空格 123456789101112131415161718192021 显示效果： 这是第一行 这是第二行 在第一行末尾有两个空格 6. 列表 列表分为有序列表和无序列表，有序列表只需要在文字前面加上“n.空格（n为任意整数）”即可，这里并不关心多个列表之间整数n的顺序性，只要是整数就行。 无序列表只需要在文字前面加上“（标识符）空格”即可。 ![例子](/images/posts/markdown/listtable.png) 小时效果： 无序表格例子： * 第一列 * 第二列 * 第三列 有序表格例子： 1. 第一列 2. 第二列 3. 第三列 待办列表：表示是否勾选状态（注意：[]前后都要有空格） - [ ] 不勾选 - [X] 勾选 7. 分割线 需要水平分割线，只需要加上两个以上星号（*），或者两个以上减号（—），或者两个以上等号（===）或（_）即可。 1234 显示效果： ____________8. 代码块以及高亮 在代码段的首行前加上这三个字符，在代码段的尾行后再加上这三个字符，该字符为英语键盘下的上点。 代码块` 表格表格是Markdown的鸡肋。显示效果：|表头第一列|表头第二列||———-|:——–:||表项第一列|表项第二列||表项第一列|表项第二列| 引用在整个段落的前面加上“&gt;”和空格显示效果： 单行引用 hello world! 多行引用 hello world!hello world!hello world!或者：hello world!hello world!hello world! 多层嵌套 aaaaaa bbbbbb cccccc 脚注语法标记：[^1]+[^1]:注释内容（[^1]是角标，[^1]:注释内容是对应的注释列表，必须一一对应）解说：写文章时，不可避免要用到读者陌生的词汇或典故，就地解释会把文风带偏，不作说明显然治学不严，脚注为此而生。显示效果：我是一个神，如吉尔伽美什[^7]一样梦幻般的人物。[^7]:吉尔伽美什，是印度的一个万能神。 链接语法符号：（[ ]中放锚文本，()中放链接地址）例如：百度解说：根据不同使用场景，文字链接有内联和引用两种方式。 内联方式，满足一般使用需求，直观方便，即用即写。 引用方式，适合添加多个网址的文章，可以避免在正文中出现大量网址，保持编辑可读性；也适合同一网址多处引用，当网址有改动或修改时，只需修改列表即可，无需逐个修改，类似宏定义。双引号内的内容可以省略，为鼠标悬浮时候的说明显示效果：内联方式：百度豆瓣local引用方式(双引号里面的标题可省略)：看电影[点这里][1]看图片[点这里][2]看美女[点这里][3]1]:https://www.douban.com/ “douban”2]:http://huaban.com/ “huaban”3]:http://huaban.com/pins/771666576/ “smg” 图片与内联方式相似，但是要加感叹号。显示效果： 内联图片或 引用图片![Alt text][id] [id]: url/to/image “Optional title attribute”]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慎独]]></title>
    <url>%2F2018%2F03%2F11%2F2018-03-11-%E6%85%8E%E7%8B%AC%2F</url>
    <content type="text"><![CDATA[慎独 在初中的时候第一次接触“慎独”这个词，当时要求用慎独写一篇作文。 慎独的意思是在独处时也要严格要求自己，自觉遵守道德准则，谨慎不苟。慎独出自《中庸》：“莫见乎隐，莫显乎微，故君子慎其独也。” 1慎独是衡量一个人道德水准的试金石。一个人在公共场合不做坏事很容易，而在独处时也能不做违反道德的事情，则需要很高的道德修养。 今天 早上7点多醒来后，没有起床学习，而是赖在床上玩手机，这是其一；其二，自己身体不好，依旧做对身体不好的事情；其三，仍然没有强大的动力促使自己主动去学习。 如何走出困境 走出现在的困境，要做到以下三点： 慎独，严格要求自己； 养好身体，不熬夜，不做损伤身体的事； 专注，学习的时候要全神贯注，一定要提高效率。]]></content>
      <categories>
        <category>diary</category>
      </categories>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开启我的博客旅程]]></title>
    <url>%2F2018%2F03%2F09%2F2018-03-09-%E5%BC%80%E5%90%AF%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%97%85%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[地点：佛山广发银行 项目：广发集中身份管理平台 经过两三天的摸索，我的博客终于上线了！ 博客用途 以后会用这个博客记录我的学习工作以及生活中的一些事情、想法等。 博客搭建 这个博客使用jekyll和GitHub搭建的，后面会详细介绍搭建过程。 新的旅程开始吧！]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jekyll+github搭建个人博客]]></title>
    <url>%2F2018%2F03%2F09%2F2018-03-09-jekyll%2Bgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[简单介绍建立博客的过程，详情请参考稳重的链接。 jekyll简介 Jekyll 是一个简单的博客形态的静态站点生产机器。它有一个模版目录，其中包含原始文本格式的文档，通过 Markdown （或者 Textile） 以及 Liquid 转化成一个完整的可发布的静态网站，你可以发布在任何你喜爱的服务器上。Jekyll 也可以运行在 GitHub Page 上，也就是说，你可以使用 GitHub 的服务来搭建你的项目页面、博客或者网站，而且是完全免费的。 github简介 Github Pages 是 github 公司提供的免费的静态网站托管服务，用起来方便而且功能强大，不仅没有空间限制，还可以绑定自己的域名。在 https://pages.github.com/ 首页上可以看到很多用 Github Pages 托管的网站，很漂亮。另外很多非常著名的公司和项目也都用这种方式来搭建网站，如微软和 twitter 的网站，还有 谷歌的 Material Design 图标 网站。 我的博客 我使用jekyll+github搭建的博客链接是https://zhonghua8.github.io，我的博客使用jekyll模板为von的改造版，这个改造版的链接是http://baixin.io/，我参考了他的安装教程。von的原版github地址为https://github.com/onevcat/vno-jekyll。 开始搭建博客配置github pages 默认已经有github账号，进入https://github.com/leopardpan/leopardpan.github.io将项目clone到自己的github里，然后将仓库的名称修改为自己的账号名。因为访问https://username.github.io默认可以访问这个仓库里的index.html静态页面。 安装ruby、Python、node.js、bundle、jekyll 具体请参考网上的安装教程。 连接github和本地的jekyll 将上面clone的github仓库clone到本地，然后进入根目录运行jekyll server即可通过127.0.0.0:4000访问本地启动的博客。这样就维护了博客的两套原始文件，本地和github，可以在本地编辑博客，然后push到github，也可以在github编辑clone到本地。当然也可以只在github编辑博客，不通过本地，但是通过本地编辑博客然后使用git提交到github可以锻炼git的熟练度。 为什么使用Hexo 使用Hexo只能在本地维护hexo的源文件，不能保管到github上的github pages的仓库里，不太方便，详情不述。]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
