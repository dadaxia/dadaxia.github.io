<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大侠</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-22T10:21:35.510Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>大侠</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/04/21/hello-world/"/>
    <id>http://yoursite.com/2018/04/21/hello-world/</id>
    <published>2018-04-21T06:50:19.703Z</published>
    <updated>2018-04-22T10:21:35.510Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Next-Theme"><a href="#Next-Theme" class="headerlink" title="Next Theme"></a>Next Theme</h2><p>这是我将之前jekyll上的博客转移到这里的第一篇自动生成的博客。使用Hexo在本地搭建博客，Next是一个很棒的简洁的主题。<br>Next的下载地址为<a href="https://github.com/iissnan/iissnan.github.com" target="_blank" rel="noopener">Next</a>。<br>Next官方使用文档<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">Next Document</a>。</p><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Next-Theme&quot;&gt;&lt;a href=&quot;#Next-Theme&quot; class=&quot;headerlink&quot; title=&quot;Next Theme&quot;&gt;&lt;/a&gt;Next Theme&lt;/h2&gt;&lt;p&gt;这是我将之前jekyll上的博客转移到这里的第一篇自动生成的博客。使用Hex
      
    
    </summary>
    
      <category term="blog" scheme="http://yoursite.com/categories/blog/"/>
    
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>java字符串</title>
    <link href="http://yoursite.com/2018/04/03/2018-04-03-java%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2018/04/03/2018-04-03-java字符串/</id>
    <published>2018-04-03T00:42:00.000Z</published>
    <updated>2018-04-22T09:26:12.658Z</updated>
    
    <content type="html"><![CDATA[<h3 id="不可变String"><a href="#不可变String" class="headerlink" title="不可变String"></a>不可变String</h3><p>String对象是不可变的。查看JDK文档你就会发现，String类中每一个看起来会修改String值的方法，实际都是重新创建了一个全新的String对象，以包含修改后的字符串内容。而最初的String对象则丝毫未动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Immutable &#123;</span><br><span class="line">public static String upcase(String s) &#123;</span><br><span class="line">return s.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String q = &quot;howdy&quot;;</span><br><span class="line">System.out.println(q);</span><br><span class="line">String qq = upcase(q);</span><br><span class="line">System.out.println(qq);</span><br><span class="line">System.out.println(q);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当把q传递给upcase()方法时，实际传递的是引用的一个拷贝。<strong>其实，每当把String对象作为方法的参数时，都会复制一份引用，而该引用所指的对象其实一直待在单一的物理位置上，从未动过。</strong><br>回到upcase()的定义，传入其中的引用有了名字s，只有upcase()运行的时候，局部引用s才存在。一旦upcase()运行结束，s就消失了。当然了，upcase()的返回值，其实只是最终结果的引用。这足以说明，upcase()返回的引用已经指向了一个新的对象，而原本的q则还在原地。</p><p>参考《Thinking in java》  </p><h3 id="String-StringBuilder-StringBuffer"><a href="#String-StringBuilder-StringBuffer" class="headerlink" title="String\StringBuilder\StringBuffer"></a>String\StringBuilder\StringBuffer</h3><p>我们要记住三者的特征：</p><ol><li>String字符串常量</li><li>StringBuffer字符串变量（线程安全）</li><li>StringBuilder字符串变量（线程不安全）</li></ol><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><img src="/images/posts/charsequence.png" alt="字符串"></p><p>查看API会发现，String、StringBuilder、StringBuffer都实现了CharSequence接口，内部都是用一个char数组实现，虽然它们都与字符串相关，但是其处理机制不同。</p><ol><li>String：是不可改变的量，也就是创建后不能再修改了。</li><li>StringBuffer：是一个可变字符串序列，它与String一样，在内存中保存的都是一个有序的字符串序列（char类型的数组），不同点事StringBuffer对象的值是可以改变的。</li><li>StringBuilder：与StringBuffer类基本相同，都是可变字符串序列，不同点是StringBuffer是线程安全的，StringBuilder是线程不安全的。</li></ol><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ol><li>使用String类的场景：在字符串不经常变化的场景中可以使用String类，例如常量的声明、少量的变量运算。</li><li>使用StringBuffer类的场景：在频繁进行字符串运算（如拼接、替换、删除等），并且运行在多线程环境中，则可以考虑使用StringBuffer，例如XML解析、HTTP参数解析和封装。</li><li>使用StringBuilder类的场景：在频繁进行字符串运算（如拼接、替换、删除等），并且运行在单线程环境中，则可以考虑使用StringBuilder，如SQL语句的拼装、JSON封装等。</li></ol><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>在性能方面，由于String类的操作是产生新的String对象，而StringBuilder和StringBuffer只是一个字符数组的扩容而已，所以String类的操作要远慢于StringBuffer和StringBuilder。<br>简要的说，String类和StringBuffer类型的主要性能区别其实在于String是不可变的对象，因此在每次对String类型进行改变的时候其实等于生成了一个新的String对象，然后将指针指向新的String对象。所以经常改变内容的字符串不要使用String，因为每次都产生新对象会对性能产生影响，特别当内存中无引用对象多了以后，JVM的GC就会开始工作，那性能一定会是非常慢的。<br>而如果使用了StringBuffer类则结果就不一样了，每次结果都是对StringBuffer对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用StringBuffer，特别是字符串经常改变的情况下。<br>而在某些特别情况下，String对象的字符串拼接其实是被JVM解释成了StringBuffer对象的拼接，所以这时候String对象的速度并不会比StringBuffer对象慢，而特别是以下的字符串生成中，String效率是远要StringBuffer快的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = &quot;This is only a &quot;+&quot;simple&quot;+&quot; test&quot;;</span><br><span class="line">StringBuffer sb = new StringBuffer(&quot;This ia only a&quot;).append(&quot; test&quot;);</span><br></pre></td></tr></table></figure></p><p>你会很快惊讶的发现，生成String s1对象的速度简直太快了，而这个时候StringBuffer的数据居然一点不占优势。其实这是JVM的一个把戏，在JVM里，这个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = &quot;This is only a &quot;+&quot;simple&quot;+&quot; test&quot;;</span><br><span class="line">``` </span><br><span class="line">其实就是：</span><br></pre></td></tr></table></figure></p><p>String s1 = “This is only a simple test”;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">所以当然不需要太多的时间了。但大家要注意的是，如果你的字符串是来自另外的String对象的话，速度就没那么快了，譬如：</span><br></pre></td></tr></table></figure></p><p>String s2 = “This is only a”;<br>String s3 = “simple”;<br>String s4 = “test”;<br>String s1 = s2+s3+s4;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这时候JVM会规规矩矩的按照原来的方式去做。  </span><br><span class="line"></span><br><span class="line">**又及：**  </span><br><span class="line">#### 关于equal和==    </span><br><span class="line">==用于比较两个对象的时候，是来check是否两个引用指向了同一块内存。</span><br></pre></td></tr></table></figure></p><p>String obj1 = new String(“xyz”);<br>String obj2 = new String(“xyz”);</p><p>if(obj1 == obj2){<br>    System.out.println(“obj1 == obj2 is TRUE”);<br>}else{<br>    System.out.println(“obj1 == obj2 is FALSE”);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这是输出的就是false</span><br></pre></td></tr></table></figure></p><p>String obj1 = new String(“xyz”);<br>String obj2 = obj1;<br>if(obj1 == obj2){<br>    System.out.println(“obj1 == obj2 is TRUE”);<br>}else{<br>    System.out.println(“obj1 == obj2 is FALSE”);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个输出的是true，一个特殊的情况：</span><br></pre></td></tr></table></figure></p><p>String s1 = “xyz”;<br>String s2 = “xyz”;<br>System.out.println(s1 == s2);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输出的是true。这是因为：  </span><br><span class="line">字符串缓冲池：程序在运行的时候会创建一个字符串缓冲池。  </span><br><span class="line">当使用String s1 = &quot;xyz&quot;;这样的表达式是创建字符串的时候（非new这种方式），程序首先会在这个String缓冲池中寻找相同值的对象，在String str1 = &quot;xyz&quot;;中，s1先被放到了池中，所以s2在被创建的时候，程序找到了具有相同值的str1，并将s2引用指向s1所指向的对象。  </span><br><span class="line"></span><br><span class="line">#### equals()</span><br><span class="line">equals()是Object的方法，默认情况下它与==一样，比较的是地址。  </span><br><span class="line">但是当equals()被重载之后，根据设计，equal会比较对象的value。而这个是java希望有的功能。  </span><br><span class="line">String类就重写了这个方法：</span><br></pre></td></tr></table></figure></p><p>String obj1 = new String(“xyz”);<br>String obj2 = new String(“xyz”);<br>if(obj1 == obj2){<br>    System.out.println(“obj1 == obj2 is TRUE”);<br>}else{<br>    System.out.println(“obj1 == obj2 is FALSE”);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">结果返回true。  </span><br><span class="line">总的说，String有个特点：如果程序中有多个String对象，都包含相同的字符串序列，那么这些String对象都映射到同一块内存区域，所以两次new String(&quot;hello&quot;),生成两个实例，虽然是相互独立的，但是对它们使用hashCode()应该是同样的结果。Note：字符串数组并非这样，只有String是这样。即hashCode对于String，是基于其内容的。</span><br></pre></td></tr></table></figure></p><p>public class StringHashCode {<br>    public static void main(String[] args){<br>        //输出结果相同<br>        String[] hellos = “Hello Hello”.split(“ “);<br>        System.out.println(“”+hellos[0].hashCode());<br>        System.out.println(“”+hellos[1].hashCode());<br>        //输出结果相同<br>        String a = new String(“hello”);<br>        String b = new String(“hello”);<br>        System.out.println(“”+a.hashCode());<br>        System.out.println(“”+b.hashCode());<br>    }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 结论</span><br><span class="line">String类是final类，不可以继承。对String类型最好的重用方式是组合而不是继承。  </span><br><span class="line">String有length()方法，数组有length属性。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String s = new String(&quot;xyz&quot;);创建了几个对象？  </span><br><span class="line">两个对象，一个静态存储区&quot;xyz&quot;,一个用new在堆上创建的对象。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String和StringBuffer、StringBuilder区别？  </span><br><span class="line">在大部分情况下StringBuffer &gt; String  </span><br><span class="line">Java.lang.StringBuffer是线程安全的可变字符序列。一个类似于String的字符串缓冲区，但是不能够修改。虽然在任意时间点上它都包含某种特定的可变字符序列，但通过某些方法调用可以修改序列的长度和内容。在程序中可将字符串缓存区安全地用于多线程。而且在必要时可以对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。  </span><br><span class="line">StringBuffer上的主要操作时append和insert方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效的将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append方法始终将这些字符添加到缓冲区的末端；而insert方法则在指定的点添加字符。</span><br><span class="line"></span><br><span class="line">例如，如果 z 引用一个当前内容是 “start”的字符串缓冲区对象，则此方法调用 z.append(“le”) 会使字符串缓冲区包含 “startle”( 累加); 而 z.insert(4, “le”) 将更改字符串缓冲区，使之包含 “starlet”。  </span><br><span class="line"></span><br><span class="line">在大部分情况下 StringBuilder &gt; StringBuffer  </span><br><span class="line"></span><br><span class="line">java.lang.StringBuilder 一个可变的字符序列是 JAVA 5.0 新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步，所以使用场景是单线程。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。**如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。**两者的使用方法基本相同。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">StringBuffer 和 StringBuilder 都是继承于 AbstractStringBuilder, 底层的逻辑（比如append）都包含在这个类中。</span><br></pre></td></tr></table></figure><p>public AbstractStringBuilder append(String str) {<br>       if (str == null) str = “null”;<br>       int len = str.length();<br>       ensureCapacityInternal(count + len);//查看使用空间满足，不满足扩展空间<br>       str.getChars(0, len, value, count);//getChars就是利用native的array copy,性能高效<br>       count += len;<br>       return this;<br>   }</p><p><code>`</code></p><p>StringBuffer 底层也是 char[], 数组初始化的时候就定下了大小, 如果不断的 append 肯定有超过数组大小的时候，我们是不是定义一个超大容量的数组，太浪费空间了。就像 ArrayList 的实现，采用动态扩展，每次 append 首先检查容量，容量不够就先扩展，然后复制原数组的内容到扩展以后的数组中。</p><p>参考：<a href="http://www.importnew.com/16881.html" target="_blank" rel="noopener">http://www.importnew.com/16881.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;不可变String&quot;&gt;&lt;a href=&quot;#不可变String&quot; class=&quot;headerlink&quot; title=&quot;不可变String&quot;&gt;&lt;/a&gt;不可变String&lt;/h3&gt;&lt;p&gt;String对象是不可变的。查看JDK文档你就会发现，String类中每一个看起来会
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java异常</title>
    <link href="http://yoursite.com/2018/04/02/2018-04-02-java%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2018/04/02/2018-04-02-java异常/</id>
    <published>2018-04-02T07:51:00.000Z</published>
    <updated>2018-04-22T08:52:25.034Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>程序运行时，发生的不被期望的事件，它阻止了程序的预期正常运行，这就是异常。异常发生时如何处理？<br>java提供了异常处理机制。<br>java异常处理机制能让程序在异常发生时，按照代码的预先设定的异常处理逻辑，正对性的处理异常，让程序尽最大可能恢复正常并继续执行，且保持代码的清晰。<br>java中的异常可以是函数中的语句执行时引发的，也可以是程序员通过throw语句手动抛出的，只要在java程序中产生了异常，就会用一个对应类型的异常对象来封装异常，JRE就会试图寻找异常处理程序来处理异常。<br>Throwable类是java异常类型的顶层父类，一个对象只有是Throwable类的（直接或间接）实例，它才是一个异常对象，才能被异常处理机制识别。JDK中内建了一些常用的异常类，我们也可以自定义异常。</p><h3 id="java异常的分类和类结构"><a href="#java异常的分类和类结构" class="headerlink" title="java异常的分类和类结构"></a>java异常的分类和类结构</h3><p>java标准库内建了一些通用的异常，这些类以Throwable为顶层父类。<br>Throwable又派生出Error类和Exception类。<br><strong>错误：</strong>Error类以及它的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error很少出现。因此程序员应该关注Exception为父类的分支下的各种异常类。<br><strong>异常：</strong>Exception以及它的子类，代表程序运行时发送的各种不期望发生的事件。可以被java异常处理机制使用，是异常处理的核心。<br><img src="/images/posts/throwable.png" alt="java异常体系"></p><p>总体上我们根据javac对异常的处理要求，将异常分为两类。 </p><h4 id="非检查异常"><a href="#非检查异常" class="headerlink" title="非检查异常"></a>非检查异常</h4><p><strong>非检查异常(unchecked exception)</strong>Error和RuntimeException以及它们的子类。javac在编译时，不会提示和发现这样的异常，不要求在程序中处理这类异常。所以如果愿意，我们可以编写代码处理（使用try…catch…finally）这样的异常，也可以不处理。<strong>对于这些异常，我们应该修正代码，而不是通过异常处理机制处理。这样的异常发生的原因多半是代码写的有问题。</strong>如除0异常AirthmeticException，错误的强制类型转换异常，数组索引越界ArrayIndexOutOfBoundsException，使用了空对象NullPointException等等。  </p><h4 id="检查异常"><a href="#检查异常" class="headerlink" title="检查异常"></a>检查异常</h4><p><strong>检查异常(checked exception)</strong>除了Error和RunTimeException的其它异常，javac强制要求程序员为这样的异常做预备处理工作（使用try…catch…finally）。在方法中要么用try-catch捕获它并处理，要么使用throws字句声明抛出它，否则编译不会通过。这样的异常一般是由程序的运行环境导致的。<strong>因为程序可能被运行在各种未知的环境下，而程序员无法干预程用户如何使用他编写的程序，于是程序员就应该为这样的异常时刻准备着。</strong>如SQLException，IOException，ClassNotFoundException等。  </p><p>需要明确的是：检查和非检查是对于javac来说的，这样就很好理解和区分了。</p><h3 id="初识异常"><a href="#初识异常" class="headerlink" title="初识异常"></a>初识异常</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.example;</span><br><span class="line">import java. util .Scanner ;</span><br><span class="line">public class AllDemo</span><br><span class="line">&#123;</span><br><span class="line">      public static void main (String [] args )</span><br><span class="line">      &#123;</span><br><span class="line">            System . out. println( &quot;----欢迎使用命令行除法计算器----&quot; ) ;</span><br><span class="line">            CMDCalculate ();</span><br><span class="line">      &#125;</span><br><span class="line">      public static void CMDCalculate ()</span><br><span class="line">      &#123;</span><br><span class="line">            Scanner scan = new Scanner ( System. in );</span><br><span class="line">            int num1 = scan .nextInt () ;</span><br><span class="line">            int num2 = scan .nextInt () ;</span><br><span class="line">            int result = devide (num1 , num2 ) ;</span><br><span class="line">            System . out. println( &quot;result:&quot; + result) ;</span><br><span class="line">            scan .close () ;</span><br><span class="line">      &#125;</span><br><span class="line">      public static int devide (int num1, int num2 )&#123;</span><br><span class="line">            return num1 / num2 ;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line"></span><br><span class="line">----欢迎使用命令行除法计算器----</span><br><span class="line">0</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ArithmeticException : / by zero</span><br><span class="line">     at com.example.AllDemo.devide( AllDemo.java:30 )</span><br><span class="line">     at com.example.AllDemo.CMDCalculate( AllDemo.java:22 )</span><br><span class="line">     at com.example.AllDemo.main( AllDemo.java:12 )</span><br><span class="line"></span><br><span class="line">----欢迎使用命令行除法计算器----</span><br><span class="line">r</span><br><span class="line">Exception in thread &quot;main&quot; java.util.InputMismatchException</span><br><span class="line">     at java.util.Scanner.throwFor( Scanner.java:864 )</span><br><span class="line">     at java.util.Scanner.next( Scanner.java:1485 )</span><br><span class="line">     at java.util.Scanner.nextInt( Scanner.java:2117 )</span><br><span class="line">     at java.util.Scanner.nextInt( Scanner.java:2076 )</span><br><span class="line">     at com.example.AllDemo.CMDCalculate( AllDemo.java:20 )</span><br><span class="line">     at com.example.AllDemo.main( AllDemo.java:12 )</span><br></pre></td></tr></table></figure><p>异常是在执行某个函数时引发的，而函数又是层级调用，形成调用栈的，因为，只要一个函数发生了异常，那么它所有的caller都会被异常影响。当这些被影响的函数以异常信息输出时，就形成了<strong>异常追踪栈</strong>。异常最先发生的地方叫做<strong>异常抛出点</strong>。<br><img src="/images/posts/exceptionstack.png" alt="异常追踪栈"></p><p>从上面的例子可以看出，当devide函数发生异常时，devide函数将抛出ArithmeticException异常，因此调用它的CMDCaculate函数也无法正常完成，因此也发送异常，而CMDCaculate的caller——main因为CMDCaculate抛出异常，也会发生异常，这样一直向调用栈的栈底回溯。<strong>这种行为叫异常的冒泡，异常的冒泡是为了在当前发生异常的函数或这个函数的caller找到最近的异常处理程序。</strong>由于这个例子没有任何的异常处理机制，因此最终由main抛给JRE，导致程序终止。<br>上面的代码不适用异常处理机制，也可以顺利编译，因为这两个异常都是非检查异常。但是下面的例子就必须使用异常处理机制，因为异常时检查异常。<br>代码中我使用throws声明异常，让函数的调用者去处理可能发生的异常。但是为什么只throws了IOException呢？因为FileNotFoundException是IOException的子类，在处理范围内。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void testException() throws IOException</span><br><span class="line">&#123;</span><br><span class="line">    //FileInputStream的构造函数会抛出FileNotFoundException</span><br><span class="line">    FileInputStream fileIn = new FileInputStream(&quot;E:\\a.txt&quot;);</span><br><span class="line">    </span><br><span class="line">    int word;</span><br><span class="line">    //read方法会抛出IOException</span><br><span class="line">    while((word =  fileIn.read())!=-1) </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print((char)word);</span><br><span class="line">    &#125;</span><br><span class="line">    //close方法会抛出IOException</span><br><span class="line">    fileIn.clos</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常处理的基本语法"><a href="#异常处理的基本语法" class="headerlink" title="异常处理的基本语法"></a>异常处理的基本语法</h3><p>在编写代代码处理异常时，对于检查异常，有2中不同的处理方式：使用try…catch…finally语句块处理它。或者，在函数签名中使用throws声明交给函数调用者caller去解决。  </p><h4 id="try…catch…finally语句块"><a href="#try…catch…finally语句块" class="headerlink" title="try…catch…finally语句块"></a>try…catch…finally语句块</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">//try块中放可能发生异常的代码。</span><br><span class="line">//如果执行完try且不发生异常，则接着执行finally块和finally后面的代码（如果有的话）</span><br><span class="line">//如果发生异常，则尝试去匹配catch块</span><br><span class="line">&#125;catch(SQLException SQLException)&#123;</span><br><span class="line">//每个catch块用于捕获并处理一个特定的异常，或者这个异常的子类。java7中可以将多个异常声明在一个catch中。</span><br><span class="line">//catch后面的括号定义异常类型和异常参数，如果异常与之匹配且是最先匹配到的，则虚拟机将使用这个catch块来处理异常。</span><br><span class="line">//在catch块中可以使用这个快的异常参数来获取异常的相关信息。异常参数是这个catch块中的局部变量，其它块不能访问。</span><br><span class="line">//如果当前try块中发生的异常在后续的所有catch中都没有捕获到，则先去执行finally，然后到这个函数的外部caller中去匹配异常处理器。</span><br><span class="line">//如果try中没有发生异常，则所有的catch块将被忽略。</span><br><span class="line">&#125;catch(Exception exception)&#123;</span><br><span class="line">//...</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">//finally块通常是可选的。</span><br><span class="line">//无论异常是否发生，异常是否匹配被处理，finally都会被执行。</span><br><span class="line">//一个try至少要有一个catch块，否则，至少要有一个finally块。但是finally不能用来处理异常，finally不会捕获异常。</span><br><span class="line">//finally主要做一些清理工作，如流的关闭，数据库连接的关闭等。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意的地方：</strong>  </p><ol><li>try块中局部变量和catch块中的局部变量（包括异常变量），以及finally中的局部变量，它们之间不可共享使用。</li><li>每一个catch块用来处理一个异常。异常匹配是按照catch块的顺序从上往下寻找的，只有第一个匹配的catch会得到执行。匹配时，不仅运行精确匹配，也支持父类匹配，因此，<strong>如果同一个try块下的有多个catch异常类型有父子关系，应该讲子类异常放在前面，父类异常放在后面，这样保证每一个catch块存在都有意义。</strong>  </li><li><strong>java中，异常处理的任务就是将执行控制流从异常发生的地方转移到能够处理这种异常的地方去。也就是说：当一个函数的某个条件发生异常时，这条语句的后面的语句不会再执行，它失去了焦点。执行流跳转到最近的匹配的异常处理catch代码块区执行，异常处理完后，执行流会接着“处理了这个异常的catch代码块”后面接着执行。</strong><br>有的编程语言当异常被处理后，控制流会恢复到异常抛出点接着执行，这种策略叫做：resumption model of exception handing（恢复式异常处理模式）<br>而java则是让执行流恢复到处理了异常的catch块后接着执行，这种策略叫做：termination model of exception handing（终结式异常处理模式）  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void mian(String[] args)&#123;</span><br><span class="line">try&#123;</span><br><span class="line">foo();</span><br><span class="line">&#125;catch(ArithmeticException ae)&#123;</span><br><span class="line">System.out.println(&quot;处理异常&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void foo()&#123;</span><br><span class="line">int a = 5/0;//异常抛出点</span><br><span class="line">System.out.println(&quot;为什么还不给我涨工资！！！！&quot;);//不会执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="throws函数声明"><a href="#throws函数声明" class="headerlink" title="throws函数声明"></a>throws函数声明</h4><p>throws声明：如果一个方法内部的代码会抛出异常检查（checked exception），而方法自己又没有完全处理掉，则javac保证你必须在方法的签名上使用关键字throws声明这些可能抛出的异常，否则编译不通过。<br>throws是另一种处理异常的方式，它不同于try…catch…finally，throws仅仅是将函数中可能出现的异常向调用者声明，而自己不做具体处理。<br>采取这种异常处理机制的原因可能是：方法本身不知道如何处理这样的异常，或者说让调用者处理更好，调用者需要为可能发生的异常负责。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void foo() throws ExceptionType1,ExceptionType2,ExceptionType3&#123;</span><br><span class="line">//foo内部可以抛出ExceptionType1,ExceptionType2,ExceptionType3类的异常，或者它们的子类的异常对象。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="finally块"><a href="#finally块" class="headerlink" title="finally块"></a>finally块</h4><p>finally块不管异常是否发生，只要对应的try执行了，则它一定执行。只有一种方法让finally块不执行:System.exit()。因此finally块通常用来做资源释放操作：关闭文件，关闭数据库连接等等。<br>良好的变成习惯是：在try块中打开资源，在finally块中清理释放这些资源。<br><strong>需要注意的地方：</strong>  </p><ol><li>finally块没有处理异常的能力，处理异常的只能是catch块。</li><li>在同一try…catch…finally块中，如果try中抛出异常，且有匹配的catch块，则先执行catch块，再执行finally块。如果没有匹配的catch块，则先执行finally块，然后去外面的调用者中寻找合适的catch块。<br>3.在同一try…catch…finally块中，try发生异常，且匹配的catch块中处理异常时也抛出异常，那么后面的finally也会执行：先执行finally块，然后去外围调用者中寻找合适的catch块。<br>这是正常的情况，但是也有特例。关于finally很多复杂的问题，在本文最后统一介绍。  </li></ol><h4 id="throw异常抛出语句"><a href="#throw异常抛出语句" class="headerlink" title="throw异常抛出语句"></a>throw异常抛出语句</h4><p>throw exceptionObject<br>程序员也可以通过throw语句手动显式地抛出一个异常。throw语句的后面必须是一个异常对象。<br>throw语句必须写在函数中，执行throw语句的地方就是一个异常抛出点，它和由JRE自动形成的异常抛出点没有任何差别。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void save(User user)&#123;</span><br><span class="line">if(user == null)&#123;</span><br><span class="line">throw new IllegalArgumentException(&quot;User对象为空&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常的链化"><a href="#异常的链化" class="headerlink" title="异常的链化"></a>异常的链化</h3><p>在一些大型的、模块化的软件开发中，一旦一个地方发生异常，则如骨牌效应，将导致一连串的异常。假设B模块完成自己的逻辑需要调用A模块的方法，如果A模块发生异常，则B也不能完成而发生异常，但是在B抛出异常时，会将A的异常信息掩盖掉，这将是的异常的根源信息丢失。异常的链化可以将多个模块的异常串联起来，使得异常信息不会丢失。<br>异常链化以一个异常对象为参数构造新的异常对象。新的异常对象将包含先前异常的信息。这项技术主要是异常类的一个带Throwable参数的函数来实现的。这个当做参数的异常，我们叫它根源异常（cause）。<br>查看Throwable类源码，可以发现里面有一个Throwable字段的cause，就是它保存了构造时传递的根源异常参数。这种设计和链表的结点类设计如出一辙，因此形成链也是自然的了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Throwable implements Serializable&#123;</span><br><span class="line">private Throwable cause = this;</span><br><span class="line"></span><br><span class="line">public Throwable(String message, Throwable cause)&#123;</span><br><span class="line">fillInStackTrace();</span><br><span class="line">detailMessage = message;</span><br><span class="line">this.cause = cause;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Throwable(Throwable cause)&#123;</span><br><span class="line">fillInStackTrace();</span><br><span class="line">detailMessage = (cause==null ? null : cause.toString());</span><br><span class="line">this.cause cause;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个例子，演示了异常的链化：从命令行输入2个int，将它们相加，输出。输入的数不是int，则导致getInputNumbers异常，从而导致add函数异常，则可以在add函数中抛出一个链化的异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">System.out.println(&quot;请输入2个加数&quot;);</span><br><span class="line">int result;</span><br><span class="line">try&#123;</span><br><span class="line">result = add();</span><br><span class="line">System.out.println(&quot;结果：&quot;+result);</span><br><span class="line">&#125;catch(Exception exception)&#123;</span><br><span class="line">exception.printStack();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取输入的2个整数返回</span><br><span class="line">private static List&lt;Integer&gt; getInputNumbers()&#123;</span><br><span class="line">List&lt;Integer&gt; nums = new ArrayList&lt;Integer&gt;();</span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">try&#123;</span><br><span class="line">int num1 = scan.nextInt();</span><br><span class="line">int num2 = scan.nextInt();</span><br><span class="line">nums.add(new Integer(num1));</span><br><span class="line">nums.add(new Integer(num2));</span><br><span class="line">&#125;catch(InputMismatchException immExp)&#123;</span><br><span class="line">throw new Exception(&quot;计算失败&quot;,immExp);//链化：以一个异常对象为参数构造新的异常对象。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line"></span><br><span class="line">请输入2个加数</span><br><span class="line">r 1</span><br><span class="line">java.lang.Exception: 计算失败</span><br><span class="line">    at practise.ExceptionTest.add(ExceptionTest.java:53)</span><br><span class="line">    at practise.ExceptionTest.main(ExceptionTest.java:18)</span><br><span class="line">Caused by: java.util.InputMismatchException</span><br><span class="line">    at java.util.Scanner.throwFor(Scanner.java:864)</span><br><span class="line">    at java.util.Scanner.next(Scanner.java:1485)</span><br><span class="line">    at java.util.Scanner.nextInt(Scanner.java:2117)</span><br><span class="line">    at java.util.Scanner.nextInt(Scanner.java:2076)</span><br><span class="line">    at practise.ExceptionTest.getInputNumbers(ExceptionTest.java:30)</span><br><span class="line">    at practise.ExceptionTest.add(ExceptionTest.java:48)</span><br><span class="line">    ... 1 more</span><br></pre></td></tr></table></figure><p><img src="/images/posts/lianhua.png" alt="异常链化"></p><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>如果要自定义异常，则扩展Exception类即可，因此这样的自定义异常都属于检查异常（checked exception）。如果要自定义非检查异常，则扩展RuntimeException。<br>按照国际惯例，自定义的异常应该总是包含如下的构造函数：  </p><ol><li>一个无参构造器</li><li>一个带有String参数的构造函数，并传递给父类的构造函数</li><li>一个带有String参数和Throwable参数，并都传递给父类构函数</li><li>一个带有Throwable参数的构造函数，并传递给父类的构造函数  </li></ol><p>下面是IOException类的完整源代码，可以借鉴：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class IOException extends Exception&#123;</span><br><span class="line">static final long seriaVersionUID = 7818375828146090155L;</span><br><span class="line"></span><br><span class="line">public IOException()&#123;</span><br><span class="line">super();</span><br><span class="line">&#125;</span><br><span class="line">public IOException(String message)&#123;</span><br><span class="line">super(message);</span><br><span class="line">&#125;</span><br><span class="line">public IOException(String message,Throwable cause)&#123;</span><br><span class="line">super(message,cause);</span><br><span class="line">&#125;</span><br><span class="line">public IOException(Throwable cause)&#123;</span><br><span class="line">super(cause);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常注意的事项"><a href="#异常注意的事项" class="headerlink" title="异常注意的事项"></a>异常注意的事项</h3><ol><li>当子类重写父类的带有throws声明的函数时，其throws声明的异常必须在父类异常的可控范围内——用于处理父类的throws方法的异常处理器，必须也用适于子类的这个带throws方法。这是为了支持多态。<br>例如，父类方法throws的是2个异常，子类就不能throws3个及以上的异常。父类throws IOException，子类就必须throws IOException或者IOException的子类。<br>下面的例子会说明：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Father &#123;</span><br><span class="line">public void start() throws IOException&#123;</span><br><span class="line">throw new IOException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Father &#123;</span><br><span class="line">public void start() throws Exception&#123;</span><br><span class="line">throw new SQLException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//*******************************************假设上面的代码是允许的，实际是错误的***************************************</span><br><span class="line"></span><br><span class="line">class Test&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Father[] objs = new Father[2];</span><br><span class="line">objs[0] = new Father();</span><br><span class="line">objs[1] = new Son();</span><br><span class="line"></span><br><span class="line">for(Father obj:objs)&#123;</span><br><span class="line">//因为Son类抛出的实质是SQLException，而IOException无法处理它。</span><br><span class="line">//那么这里的try...catch就不能处理Son中的异常。</span><br><span class="line">//多态就不能实现了。</span><br><span class="line">try&#123;</span><br><span class="line">obj.start();</span><br><span class="line">&#125;catch(IOException e)&#123;</span><br><span class="line">//处理IOException</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>java中的异常是线程独立的，本线程的问题应该由本线程自己解决，不能委托到外部，也不会直接影响到其它线程的执行。即本线程的异常如果没有被处理，只能回导致本线程的运行中断，不会造成其它线程中断。</li></ol><h3 id="finally块和return"><a href="#finally块和return" class="headerlink" title="finally块和return"></a>finally块和return</h3><p>首先一个不容易理解的事实：在try块中即使有return，break，continue等改变执行流的语句，finally也会执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">    int re = bar();</span><br><span class="line">    System.out.println(re);</span><br><span class="line">&#125;</span><br><span class="line">private static int bar() </span><br><span class="line">&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        return 5;</span><br><span class="line">    &#125; finally&#123;</span><br><span class="line">        System.out.println(&quot;finally&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*输出：</span><br><span class="line">finally</span><br><span class="line">5</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>很多人在面临这个问题时，总是在归纳执行的顺序和规律，不过我还是觉得很难理解。我自己总结了一个方法，用如下的GIF图说明：</p><p><img src="/images/posts/finally.gif" alt="finally"></p><p>也就是说：try…catch…finally中的return只要能够执行，就都执行了，它们共同向一个内存地址（假设地址是0x80）写入返回值，后执行的将覆盖先执行的数据，而真正被调用者取的返回值就是最后一次写入的。那么，按照这个思想，下面的这个例子也就不难理解了。</p><p><strong>finally中的return会覆盖try…catch中的返回值</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        int result;</span><br><span class="line">        </span><br><span class="line">        result  =  foo();</span><br><span class="line">        System.out.println(result);     /////////2</span><br><span class="line">        </span><br><span class="line">        result = bar();</span><br><span class="line">        System.out.println(result);    /////////2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;finally&quot;)</span><br><span class="line">    public static int foo()</span><br><span class="line">    &#123;</span><br><span class="line">        trz&#123;</span><br><span class="line">            int a = 5 / 0;</span><br><span class="line">        &#125; catch (Exception e)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; finally&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;finally&quot;)</span><br><span class="line">    public static int bar()</span><br><span class="line">    &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>finally中的return会抑制（消灭）前面try或者catch块中的异常</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class TestException</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        int result;</span><br><span class="line">        try&#123;</span><br><span class="line">            result = foo();</span><br><span class="line">            System.out.println(result);           //输出100</span><br><span class="line">        &#125; catch (Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());    //没有捕获到异常</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        try&#123;</span><br><span class="line">            result  = bar();</span><br><span class="line">            System.out.println(result);           //输出100</span><br><span class="line">        &#125; catch (Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());    //没有捕获到异常</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //catch中的异常被抑制</span><br><span class="line">    @SuppressWarnings(&quot;finally&quot;)</span><br><span class="line">    public static int foo() throws Exception</span><br><span class="line">    &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int a = 5/0;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;catch(ArithmeticException amExp) &#123;</span><br><span class="line">            throw new Exception(&quot;我将被忽略，因为下面的finally中使用了return&quot;);</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            return 100;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //try中的异常被抑制</span><br><span class="line">    @SuppressWarnings(&quot;finally&quot;)</span><br><span class="line">    public static int bar() throws Exception</span><br><span class="line">    &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int a = 5/0;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            return 100;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>finally中的异常会覆盖（消灭）try或者catch中的异常</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class TestException</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        int result;</span><br><span class="line">        try&#123;</span><br><span class="line">            result = foo();</span><br><span class="line">        &#125; catch (Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());    //输出：我是finaly中的Exception</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        try&#123;</span><br><span class="line">            result  = bar();</span><br><span class="line">        &#125; catch (Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());    //输出：我是finaly中的Exception</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //catch中的异常被抑制</span><br><span class="line">    @SuppressWarnings(&quot;finally&quot;)</span><br><span class="line">    public static int foo() throws Exception</span><br><span class="line">    &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int a = 5/0;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;catch(ArithmeticException amExp) &#123;</span><br><span class="line">            throw new Exception(&quot;我将被忽略，因为下面的finally中抛出了新的异常&quot;);</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            throw new Exception(&quot;我是finaly中的Exception&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //try中的异常被抑制</span><br><span class="line">    @SuppressWarnings(&quot;finally&quot;)</span><br><span class="line">    public static int bar() throws Exception</span><br><span class="line">    &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int a = 5/0;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            throw new Exception(&quot;我是finaly中的Exception&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子都异于常人的编码思维，因此建议：</p><ol><li>不在finally中使用return</li><li>不要在finally中抛出异常</li><li>减轻finally的任务，不要在finally中做一些其它的事情，finally块仅仅用来释放资源是最合适的</li><li>尽量将所有的return都写在函数的最后面，而不是在try…catch…fianlly中。</li></ol><p>转自：<a href="https://www.cnblogs.com/lulipro/p/7504267.html" target="_blank" rel="noopener">https://www.cnblogs.com/lulipro/p/7504267.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;程序运行时，发生的不被期望的事件，它阻止了程序的预期正常运行，这就是异常。异常发生时如何处理？&lt;br&gt;java提供了异常处理机制。&lt;br&gt;j
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java集合之迭代器</title>
    <link href="http://yoursite.com/2018/03/29/2018-03-29-Java%E9%9B%86%E5%90%88%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>http://yoursite.com/2018/03/29/2018-03-29-Java集合之迭代器/</id>
    <published>2018-03-29T03:20:00.000Z</published>
    <updated>2018-04-22T08:47:10.519Z</updated>
    
    <content type="html"><![CDATA[<p>迭代器是一个对象，它的工作是遍历并选择序列中的对象，而客户端程序员不必知道或关心该序列的底层结构。此外迭代器通常被称为轻量级对象：创建它的代价小。因此经常会见到对迭代器有些奇怪的限制，例如，Java的Iterator只能单向移动，这个Iterator只能用来：  </p><ol><li>使用方法iterator()要求容器返回一个Iterator。Iterator将准备好返回序列的第一个元素。</li><li>使用next()获得序列中下一个元素。</li><li>使用hasNext()检查序列中是否还有元素。</li><li>使用remove()将迭代器返回的元素删除。</li></ol><p>如果只是向前遍历List，并不打算修改List对象本身，那么用foreach语法会显得更加简洁。<br>Iterator还可以移除由next()产生的最后一个元素，这意味着在调用remove()之前必须先调用next()。</p><h3 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h3><p>ListIterator是一个更加强大的Iterator的子类集，它只能用于各种List类的访问。尽管Iterator只能向前移动，但是ListIterator可以双向移动。它还可以产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引，并且可以用set()方法替换它访问的最后一个元素。可以通过调用listIterator()方法产生一个指向List开始处的ListIterator，并且还可以通过调用listIterator(n)方法创建一个一开始就指向列表索引为n的元素处的ListIterator。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;迭代器是一个对象，它的工作是遍历并选择序列中的对象，而客户端程序员不必知道或关心该序列的底层结构。此外迭代器通常被称为轻量级对象：创建它的代价小。因此经常会见到对迭代器有些奇怪的限制，例如，Java的Iterator只能单向移动，这个Iterator只能用来：  &lt;/p&gt;

      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java集合之容器的打印</title>
    <link href="http://yoursite.com/2018/03/29/2018-03-29-Java%E9%9B%86%E5%90%88%E4%B9%8B%E5%AE%B9%E5%99%A8%E6%89%93%E5%8D%B0/"/>
    <id>http://yoursite.com/2018/03/29/2018-03-29-Java集合之容器打印/</id>
    <published>2018-03-29T00:39:00.000Z</published>
    <updated>2018-04-22T08:46:12.705Z</updated>
    
    <content type="html"><![CDATA[<p>必须使用Arrays.toString()来产生数组的可打印表示，但是打印容器（集合）无序任何帮助。<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class PrintingContainers &#123;</span><br><span class="line"></span><br><span class="line">static Collection fill(Collection&lt;String&gt; collection) &#123;</span><br><span class="line">collection.add(&quot;rat&quot;);</span><br><span class="line">collection.add(&quot;cat&quot;);</span><br><span class="line">collection.add(&quot;dog&quot;);</span><br><span class="line">collection.add(&quot;dog&quot;);</span><br><span class="line">return collection;</span><br><span class="line">&#125;</span><br><span class="line">static Map fill(Map&lt;String,String&gt; map) &#123;</span><br><span class="line">map.put(&quot;rat&quot;,&quot;Fuzzy&quot;);</span><br><span class="line">map.put(&quot;cat&quot;,&quot;Rags&quot;);</span><br><span class="line">map.put(&quot;dog&quot;,&quot;Bosco&quot;);</span><br><span class="line">map.put(&quot;dog&quot;,&quot;Spot&quot;);</span><br><span class="line">return map;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(fill(new ArrayList&lt;String&gt;()));</span><br><span class="line">System.out.println(fill(new LinkedList&lt;String&gt;()));</span><br><span class="line">System.out.println(fill(new HashSet&lt;String&gt;()));</span><br><span class="line">System.out.println(fill(new TreeSet&lt;String&gt;()));</span><br><span class="line">System.out.println(fill(new LinkedHashSet&lt;String&gt;()));</span><br><span class="line">System.out.println(fill(new HashMap&lt;String,String&gt;()));</span><br><span class="line">System.out.println(fill(new TreeMap&lt;String,String&gt;()));</span><br><span class="line">System.out.println(fill(new LinkedHashMap&lt;String,String&gt;()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">       [rat, cat, dog, dog]</span><br><span class="line">       [rat, cat, dog, dog]</span><br><span class="line">       [rat, cat, dog]</span><br><span class="line">       [cat, dog, rat]</span><br><span class="line">       [rat, cat, dog]</span><br><span class="line">       &#123;rat=Fuzzy, cat=Rags, dog=Spot&#125;</span><br><span class="line">       &#123;cat=Rags, dog=Spot, rat=Fuzzy&#125;</span><br><span class="line">       &#123;rat=Fuzzy, cat=Rags, dog=Spot&#125;</span><br></pre></td></tr></table></figure><p>从示例可以看出：  </p><ul><li>List以特定的顺序保存一组元素  </li><li>Set元素不能重复  </li><li>Queue只允许在容器一端插入对象，并从另一端移除对象（本例没有展示）  </li><li>Map在每个槽中保存了两个对象，即键和值，而且键不能重复。与HashSet一样，HashMap也提供了最快的查找技术，也没有按照任何明显的顺序来保存其元素。TreeMap按照比较结果的升序保存键，而LinkedHashMap则按照插入顺序保存键，同时还保留了HashMap的查询速度。</li></ul><p>查看输出会发现，默认的打印行为（适用容器的toString()方法)即可生成可读性很好的结果。Collection打印出来的内容用方括号括住，每个元素由逗号分隔。Map则用大括号括住，键与值由等号联系。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;必须使用Arrays.toString()来产生数组的可打印表示，但是打印容器（集合）无序任何帮助。&lt;br&gt;示例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java集合之List</title>
    <link href="http://yoursite.com/2018/03/29/2018-03-29-Java%E9%9B%86%E5%90%88%E4%B9%8BList/"/>
    <id>http://yoursite.com/2018/03/29/2018-03-29-Java集合之List/</id>
    <published>2018-03-28T16:00:00.000Z</published>
    <updated>2018-04-22T09:43:22.745Z</updated>
    
    <content type="html"><![CDATA[<p>List承诺可以将元素维护在特定的序列中。List在Collection的基础上添加了大量的方法，使得可以在List的中间插入和移除元素。<br>由两种类型的List：  </p><ul><li>ArrayList：长于随机访问元素，但在List中间插入和移除元素时代价较大。</li><li>LinkedList：它通过代价较低的在List中间进行插入和删除操作，提供了优化的顺序访问。LinkedList在随机访问方面相对较慢，但是它的特性集较ArrayList大。</li></ul><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList也想ArrayList一样实现了基本的List接口，但是它执行某些操作（在List的中间插入和移除）时比ArrayList更高效，但是在随机访问操作方面却要逊色一些。</p><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>“栈”通常是指“后进先出”（LIFO）的容器。有时栈也被称为叠加栈，因为最后“压入”栈的元素，第一个“弹出”栈。<br>LinkedList具有能够直接实现栈的所有功能的方法，因此可以直接将LinkedList作为栈使用。不过，有时一个真正的“栈”更能把事情搞清楚：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Stack&lt;T&gt; &#123;</span><br><span class="line">private LinkedList&lt;T&gt; storage = new LinkedList&lt;T&gt;();</span><br><span class="line">public void push(T v) &#123;</span><br><span class="line">storage.addFirst(v);</span><br><span class="line">&#125;</span><br><span class="line">public T peek() &#123;</span><br><span class="line">return storage.getFirst();</span><br><span class="line">&#125;</span><br><span class="line">public T pop() &#123;</span><br><span class="line">return storage.removeFirst();</span><br><span class="line">&#125;</span><br><span class="line">public boolean empty() &#123;</span><br><span class="line">return storage.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return storage.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过使用泛型，引入了在栈的类定义中最简单的可行示例。类名之后的<t>告诉编译器这将是一个参数化类型，而其中的类型参数，即在类被使用时将会被实际类型替换的参数，就是T。<br>Java中也有Stack类的定义，在java.util中。</t></p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set不保存重复的元素。查找是Set中最重要的操作，HashSet专门对快速查找做了优化。</p><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>队列是一个典型的先进先出（FIFO）的容器。即从容器的一端放入事物，从另一端取出，并且事物放入容器的顺序与取出的顺序相同。队列常被当做一种可靠的将对象从程序的某个区域传输到另一个区域的的途径。队列在并发编程中特别重要，因为它们可以安全地将对象从一个任务传输给另一个任务。</p><h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p>先进先出描述了最典型的队列规则。队列规则是指在给定一组队列中的元素的情况下，确定下一个弹出队列的元素的规则。先进先出声明的是下一个元素应该是等待时间最长的元素。<br><strong>优先队列</strong>声明下一个弹出元素是最需要的元素（具有最高的优先级）。例如，在飞机场，当飞机临近起飞时，这架飞机的乘客可以在办理登记手续时排到队头。如果构建了一个消息系统，某些消息比其它消息更重要，因而应该更快的地得到处理，那么它们何时得到处理就与它们何时到达无关。PriorityQueue添加到JavaSE5中，是为了提供这种行为的一种自动实现。<br>当你在PriorityQueue上调用offer()方法来插入一个对象时，这个对象会在队列中被排序。默认的排序将使用对象在队列中的自然顺序，但是你可以通过提供自己的Comparator来修改这个顺序。PriorityQueue可以确保当你调用peek()、poll()和remove()方法时，获取的元素将是队列中优先级最高的元素。<br>让PriorityQueue与Integer、String和Character这样的内置类型一起工作易如反掌。在下面的示例中，第一个值集与前一个示例中的随机值相同，因此你可以看到他们从PriorityQueue中弹出的顺序与前一个示例不同：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class QueueDemo &#123;</span><br><span class="line">public static void printQ(Queue&lt;?&gt; queue) &#123;</span><br><span class="line">while(queue.peek() != null) &#123;</span><br><span class="line">System.out.print(queue.remove()+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();</span><br><span class="line">Random random = new Random(47);</span><br><span class="line">for(int i=0; i&lt;10; i++) &#123;</span><br><span class="line">queue.offer(random.nextInt(i+10));</span><br><span class="line">&#125;</span><br><span class="line">printQ(queue);</span><br><span class="line">Queue&lt;Character&gt; qc = new LinkedList&lt;Character&gt;();</span><br><span class="line">for(char c : &quot;Brontosaurus&quot;.toCharArray())</span><br><span class="line">qc.offer(c);</span><br><span class="line">printQ(qc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OutPut:</span><br><span class="line">       8 1 1 1 5 14 3 1 0 1 </span><br><span class="line">       B r o n t o s a u r u s</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class PriorityQueueDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;Integer&gt;();</span><br><span class="line">Random random = new Random(47);</span><br><span class="line">for(int i=0; i&lt;10; i++) &#123;</span><br><span class="line">priorityQueue.offer(random.nextInt(i+10));</span><br><span class="line">&#125;</span><br><span class="line">QueueDemo.printQ(priorityQueue);</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; ints = Arrays.asList(25,22,20,18,14,9,3,1,1,2,2,3,9,14,18,21,23,25);</span><br><span class="line">priorityQueue = new PriorityQueue&lt;Integer&gt;(ints);</span><br><span class="line">QueueDemo.printQ(priorityQueue);</span><br><span class="line">priorityQueue = new PriorityQueue&lt;Integer&gt;(ints.size(),Collections.reverseOrder());</span><br><span class="line">priorityQueue.addAll(ints);</span><br><span class="line">QueueDemo.printQ(priorityQueue);</span><br><span class="line"></span><br><span class="line">String fact = &quot;EDUCATION SHOULD ESCHEW OBFUSCATION&quot;;</span><br><span class="line">List&lt;String&gt; strings = Arrays.asList(fact.split(&quot;&quot;));</span><br><span class="line">PriorityQueue&lt;String&gt; stringPQ = new PriorityQueue&lt;String&gt;(strings);</span><br><span class="line">QueueDemo.printQ(stringPQ);</span><br><span class="line">stringPQ = new PriorityQueue&lt;String&gt;(strings.size(),Collections.reverseOrder());</span><br><span class="line">stringPQ.addAll(strings);</span><br><span class="line">QueueDemo.printQ(stringPQ);</span><br><span class="line"></span><br><span class="line">Set&lt;Character&gt; charSet = new HashSet&lt;Character&gt;();</span><br><span class="line">for(char c : fact.toCharArray())</span><br><span class="line">charSet.add(c);</span><br><span class="line">PriorityQueue&lt;Character&gt; characterPQ = new PriorityQueue&lt;Character&gt;(charSet);</span><br><span class="line">QueueDemo.printQ(characterPQ);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">       0 1 1 1 1 1 3 5 8 14 </span><br><span class="line">1 1 2 2 3 3 9 9 14 14 18 18 20 21 22 23 25 25 </span><br><span class="line">25 25 23 22 21 20 18 18 14 14 9 9 3 3 2 2 1 1 </span><br><span class="line">      A A B C C C D D E E E F H H I I L N N O O O O S S S T T U U U W </span><br><span class="line">W U U U T T S S S O O O O N N L I I H H F E E E D D C C C B A A       </span><br><span class="line">  A B C D E F H I L N O S T U W</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;List承诺可以将元素维护在特定的序列中。List在Collection的基础上添加了大量的方法，使得可以在List的中间插入和移除元素。&lt;br&gt;由两种类型的List：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ArrayList：长于随机访问元素，但在List中间插入和移除元素时代价
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java集合之添加元素</title>
    <link href="http://yoursite.com/2018/03/28/2018-03-29-%E9%9B%86%E5%90%88%E4%B9%8B%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2018/03/28/2018-03-29-集合之添加元素/</id>
    <published>2018-03-28T05:50:00.000Z</published>
    <updated>2018-04-22T08:45:34.942Z</updated>
    
    <content type="html"><![CDATA[<p>在java.util包中的Arrays和Collections类中都有很多实用的方法，可以在Collection中添加一组元素。  </p><ol><li>Arrays.asList()方法接受一个数组或是一个用逗号分隔的元素列表（实用可变参数），并将其转换为一个List对象。  </li><li>Collections.addAll()方法接受一个collection对象，以及一个数组或是一个用逗号分割的列表，将元素添加到Collection中。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class AddingGroups &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">Collection&lt;Integer&gt; collection = new ArrayList&lt;Integer&gt;(Arrays.asList(1,2,3,4,5));</span><br><span class="line">Integer[] moreInts = &#123;6,7,8,9,10&#125;;</span><br><span class="line">collection.addAll(Arrays.asList(moreInts));</span><br><span class="line">Collections.addAll(collection, 11,12,13,14,15);</span><br><span class="line">Collections.addAll(collection, moreInts);</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(16,17,18,19,20);</span><br><span class="line">list.set(1, 99);</span><br><span class="line">//list.add(21);</span><br><span class="line">//for(Integer i : list) &#123;</span><br><span class="line">//System.out.println(i);</span><br><span class="line">//&#125;</span><br><span class="line">for(Integer i : collection) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面注释掉的list.add(21)运行时会报：Runtime error because the underlying array cannot be resized.可以将Arrays.asList()的输出作为List，但是在这种情况下，其底层表示的是数组，因此不能调整尺寸。如果试图用add()或delete()方法在这种列表中添加或删除元素，就可能引发改变数组尺寸的尝试，因此将在运行时获取“Unsupported Operation(不支持的操作)”错误。<br>Collection.addAll()成员方法只能接受一个Collection对象作为参数，因此它不如Arrays.asList()和Collections.addAll()灵活，整两个方法使用的都是可变参数列表。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在java.util包中的Arrays和Collections类中都有很多实用的方法，可以在Collection中添加一组元素。  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Arrays.asList()方法接受一个数组或是一个用逗号分隔的元素列表（实用可变参数），并将其转换为一个Lis
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java集合（3）</title>
    <link href="http://yoursite.com/2018/03/28/2018-03-28-java%E9%9B%86%E5%90%883/"/>
    <id>http://yoursite.com/2018/03/28/2018-03-28-java集合3/</id>
    <published>2018-03-28T00:50:00.000Z</published>
    <updated>2018-04-22T09:45:56.606Z</updated>
    
    <content type="html"><![CDATA[<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ol><li>定义<br>泛型是一种把明确类型的工作放在了创建对象或调用方法时采取明确的特殊的类型。</li><li>格式<br>&lt;数据类型&gt;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure></li></ol><p><string>即表示是泛型。</string></p><ol start="3"><li>泛型的好处</li></ol><ul><li>解决了黄色警告线问题</li><li>把运行期间的转换异常提前到了编译期间</li><li>优化了程序设计，不需要做强制类型转换了</li></ul><ol start="4"><li>泛型的发展</li></ol><ul><li>泛型类</li><li>泛型方法</li><li>泛型接口</li></ul><ol start="5"><li>泛型的使用<br>看API中的类或者接口，其后带有&lt;&gt;就是泛型的应用。一般在集合中。</li></ol><h3 id="增强for循环（JDK1-5之后新特性）"><a href="#增强for循环（JDK1-5之后新特性）" class="headerlink" title="增强for循环（JDK1.5之后新特性）"></a>增强for循环（JDK1.5之后新特性）</h3><ol><li>格式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(数组或者Collection集合的元素类型 变量 ： 数组或者Collection集合的对象)&#123;</span><br><span class="line">直接使用变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();</span><br><span class="line">map.put(&quot;二阳&quot;,23);</span><br><span class="line">map.put(&quot;二蛋&quot;,24);</span><br><span class="line">map.put(&quot;二光&quot;,25);</span><br><span class="line">Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">for(String key : keys)&#123;</span><br><span class="line">Integer value = map.get(key);</span><br><span class="line">System.out.println(key+&quot;***&quot;+value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>好处<br>方便了数组和Collection集合的遍历。</p></li><li><p>注意</p></li></ol><ul><li>增强for是用来替代迭代器的</li><li>不要在用增强for遍历集合的时候，用集合对集合本身进行修改</li></ul><ol start="4"><li>遍历集合三种方式<br>(1) 迭代器<br>(2) 普通for+get()<br>(3) 增强for(工作时用)  </li></ol><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><p>常用到的工具类有两种，Collections和Arrays，如下图：<br><img src="/images/posts/collections.png" alt="工具类"></p><p>参考文献：<a href="https://blog.csdn.net/haovip123/article/details/45425021" target="_blank" rel="noopener">https://blog.csdn.net/haovip123/article/details/45425021</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;泛型&quot;&gt;&lt;a href=&quot;#泛型&quot; class=&quot;headerlink&quot; title=&quot;泛型&quot;&gt;&lt;/a&gt;泛型&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;定义&lt;br&gt;泛型是一种把明确类型的工作放在了创建对象或调用方法时采取明确的特殊的类型。&lt;/li&gt;
&lt;li&gt;格式&lt;br&gt;&amp;lt;数
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java集合（2）</title>
    <link href="http://yoursite.com/2018/03/27/2018-03-27-java%E9%9B%86%E5%90%882/"/>
    <id>http://yoursite.com/2018/03/27/2018-03-27-java集合2/</id>
    <published>2018-03-27T14:32:00.000Z</published>
    <updated>2018-04-22T09:56:33.967Z</updated>
    
    <content type="html"><![CDATA[<h3 id="迭代器的使用"><a href="#迭代器的使用" class="headerlink" title="迭代器的使用"></a>迭代器的使用</h3><h4 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h4><ol><li>通过集合对象获取迭代器</li><li>通过迭代器对象判断</li><li>通过迭代器对象获取</li></ol><h4 id="迭代器原理"><a href="#迭代器原理" class="headerlink" title="迭代器原理"></a>迭代器原理</h4><p>由于多种集合的数据结构不同，所以存储方式不同，所以，取出方式也不同。<br>这时候我们就把判断和获取功能定义在一个接口中，将来，遍历哪种集合的时候，只要该集合内部实现该接口即可。</p><h4 id="迭代器源码"><a href="#迭代器源码" class="headerlink" title="迭代器源码"></a>迭代器源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterator&#123;</span><br><span class="line">public abstract boolean hasNext();</span><br><span class="line">public abstract Object next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Collection&#123;</span><br><span class="line">public abstract Iterator iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface List extends Collection&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ArrayList implements List&#123;</span><br><span class="line">public Iterator iterator()&#123;</span><br><span class="line">return Itr();</span><br><span class="line">&#125;</span><br><span class="line">private class Itr implements Iterator&#123;</span><br><span class="line">public boolean hasNext()&#123;...&#125;</span><br><span class="line">public Object next()&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Collection存储字符串和自定义对象并通过迭代器遍历"><a href="#Collection存储字符串和自定义对象并通过迭代器遍历" class="headerlink" title="Collection存储字符串和自定义对象并通过迭代器遍历"></a>Collection存储字符串和自定义对象并通过迭代器遍历</h3><ol><li><p>存储字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Collection c = new ArrayList();</span><br><span class="line">c.add(&quot;hello&quot;);</span><br><span class="line">c.add(&quot;world&quot;);</span><br><span class="line">c.add(&quot;java&quot;);</span><br><span class="line"></span><br><span class="line">Iterator it = c.iterator();</span><br><span class="line">while(it.hasNext())&#123;</span><br><span class="line">String s = (String)it.next();</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>存储自定义对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Collection c = new ArrayList();</span><br><span class="line">Student s1 = new Student1(&quot;林青霞&quot;,26);//Student类的定义省略</span><br><span class="line">c.add(s1);</span><br><span class="line">Iterator it = c.iterator();</span><br><span class="line">while(it.hasNext())&#123;</span><br><span class="line">String s = (String)it.next();</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>ListLiterator迭代器是Iterator的子接口</strong>，所以List的遍历方式有三种：</p><ol><li>Iterator迭代器</li><li>ListIterator迭代器</li><li>普通for+get()</li></ol><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map是一个键值形式的集合，它的元素都是有键和值组成。<strong>Map的键(Key)是唯一的，值(value)可以重复。</strong><br><img src="/images/posts/map.png" alt="Map"></p><h4 id="Map的功能"><a href="#Map的功能" class="headerlink" title="Map的功能"></a>Map的功能</h4><h5 id="A：添加功能"><a href="#A：添加功能" class="headerlink" title="A：添加功能"></a>A：添加功能</h5><pre><code>V put(K key,V value):当key在集合中不存在时添加元素，当key存在时替换元素</code></pre><h5 id="B：判断功能"><a href="#B：判断功能" class="headerlink" title="B：判断功能"></a>B：判断功能</h5><pre><code>boolean containsKey(Object key):判断指定的键在集合中是否存在boolean containsValue(Object value):判断指定的值在集合中是否存在boolean isEmpty():判断集合是否为空</code></pre><h5 id="C：删除功能"><a href="#C：删除功能" class="headerlink" title="C：删除功能"></a>C：删除功能</h5><pre><code>void clear():清除所有键值对数据</code></pre><h5 id="D：获取功能"><a href="#D：获取功能" class="headerlink" title="D：获取功能"></a>D：获取功能</h5><pre><code>Object get(Object key):根据键获取值Set&lt;Key&gt; keySet():所有键的集合Collection&lt;V&gt; values():所有值的集合</code></pre><h5 id="E：长度功能"><a href="#E：长度功能" class="headerlink" title="E：长度功能"></a>E：长度功能</h5><pre><code>int size()</code></pre><p><strong>Map包括HashMap、HashTable和TreeMap。其中，HashTable已经被HashMap取代，这里不做讨论（HashMap支持null，HashTable不支持null）。</strong></p><h4 id="Map遍历的两种方式"><a href="#Map遍历的两种方式" class="headerlink" title="Map遍历的两种方式"></a>Map遍历的两种方式</h4><ol><li><p>键找值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();</span><br><span class="line">map.put(&quot;二阳&quot;,23);</span><br><span class="line">map.put(&quot;二蛋&quot;,24);</span><br><span class="line">map.put(&quot;二光&quot;,25);</span><br><span class="line">Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">for(String key : keys)&#123;</span><br><span class="line">Integer value = map.get(key);</span><br><span class="line">System.out.println(key+&quot;***&quot;+value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>键值对</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();</span><br><span class="line">map.put(&quot;二阳&quot;,23);</span><br><span class="line">map.put(&quot;二蛋&quot;,24);</span><br><span class="line">map.put(&quot;二光&quot;,25);</span><br><span class="line"></span><br><span class="line">Set&lt;Map.Entry&lt;String,Integer&gt;&gt; set = map.entrySet();//获取键值对集合</span><br><span class="line">for(Map.Entry&lt;String,Integer&gt; me:set)&#123;</span><br><span class="line">String key = me.getKey();</span><br><span class="line">Integer value = me.getValue();</span><br><span class="line">System.out.println(key+&quot;***&quot;+value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>参考文献：<a href="https://blog.csdn.net/haovip123/article/details/45424711" target="_blank" rel="noopener">https://blog.csdn.net/haovip123/article/details/45424711</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;迭代器的使用&quot;&gt;&lt;a href=&quot;#迭代器的使用&quot; class=&quot;headerlink&quot; title=&quot;迭代器的使用&quot;&gt;&lt;/a&gt;迭代器的使用&lt;/h3&gt;&lt;h4 id=&quot;使用步骤：&quot;&gt;&lt;a href=&quot;#使用步骤：&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java集合（1）</title>
    <link href="http://yoursite.com/2018/03/27/2018-03-27-Java%E9%9B%86%E5%90%881/"/>
    <id>http://yoursite.com/2018/03/27/2018-03-27-Java集合1/</id>
    <published>2018-03-26T16:00:00.000Z</published>
    <updated>2018-04-22T09:51:14.295Z</updated>
    
    <content type="html"><![CDATA[<h3 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h3><p>Java是一种面向对象的语言，如果要针对多个对象进行操作，就必须对多个对象进行存储。而数组长度固定，不能满足变化的要求。所以，Java提供了集合。<br>特点：  </p><ol><li>长度可以发生变化</li><li>只能存储对象</li><li>可以存储多种类型对象<br>集合和数组的区别：<br>数组：长度固定，可以存储基本类型和引用类型，元素类型必须一致<br>集合：长度可变，可以存储引用类型，元素类型可以不一致</li></ol><h3 id="集合体系"><a href="#集合体系" class="headerlink" title="集合体系"></a>集合体系</h3><p>集合作为一个容器，可以存储多个元素，但是由于数据结构的不同，Java提供了多种集合类。将集合类中共性的功能，不断向上抽取，最终形成了集合体系结构。<br>数据结构：数据存储的方式<br>Java集合类的关系图：<br><img src="/images/posts/jihe.png" alt="集合体系"><br><img src="/images/posts/jihetixi.png" alt="集合体系结构"></p><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p>Collection是最基本的集合接口，一个collection代表一组Object，即Collection的元素（Elements）。一些Collection允许存储相同的元素而另一些不行。一些能排序而另一些不行，于是衍生出两个字类接口List和Set。<br><img src="/images/posts/listandset.png" alt="List和Set"></p><h3 id="Collection基本功能"><a href="#Collection基本功能" class="headerlink" title="Collection基本功能"></a>Collection基本功能</h3><h5 id="A：添加功能"><a href="#A：添加功能" class="headerlink" title="A：添加功能"></a>A：添加功能</h5><pre><code>boolean add(Object obj):向集合中添加一个元素boolean addAll(Collection c):向集合中添加一个集合元素</code></pre><h5 id="B：删除功能"><a href="#B：删除功能" class="headerlink" title="B：删除功能"></a>B：删除功能</h5><pre><code>void clear():删除集合中的所有元素boolean remove(Object obj):从集合中删除指定的元素boolean removeAll(Collection c):从集合中删除一个指定的集合元素</code></pre><h5 id="C：判断功能"><a href="#C：判断功能" class="headerlink" title="C：判断功能"></a>C：判断功能</h5><pre><code>boolean isEmpty():判断集合是否为空boolean contains(Object obj):判断集合中是否存在指定的元素boolean containsAll(Collection c):判断集合中是否存在指定的一个集合中的元素</code></pre><h5 id="D：遍历功能"><a href="#D：遍历功能" class="headerlink" title="D：遍历功能"></a>D：遍历功能</h5><pre><code>Iterator iterator():就是用来获取集合中的没有给元素</code></pre><h5 id="E：长度功能"><a href="#E：长度功能" class="headerlink" title="E：长度功能"></a>E：长度功能</h5><pre><code>int size():获取集合中元素的个数</code></pre><h5 id="F：交集功能"><a href="#F：交集功能" class="headerlink" title="F：交集功能"></a>F：交集功能</h5><pre><code>boolean retainAll(Collection c):判断两个集合中是否有相同的元素</code></pre><h5 id="G：把集合转换为数组"><a href="#G：把集合转换为数组" class="headerlink" title="G：把集合转换为数组"></a>G：把集合转换为数组</h5><pre><code>Object[] toArray():把集合变成数组</code></pre><h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><p><strong>List接口下的集合元素存储有序，可以重复</strong><br>List的特有功能：  </p><h5 id="A：添加功能-1"><a href="#A：添加功能-1" class="headerlink" title="A：添加功能"></a>A：添加功能</h5><pre><code>void add(int index, Object obj):在指定位置添加元素</code></pre><h5 id="B：删除功能-1"><a href="#B：删除功能-1" class="headerlink" title="B：删除功能"></a>B：删除功能</h5><pre><code>Object remove(int index):根据指定索引删除元素，并把删除的元素返回</code></pre><h5 id="C：修改功能"><a href="#C：修改功能" class="headerlink" title="C：修改功能"></a>C：修改功能</h5><pre><code>Object set(int index,Object obj):把指定索引位置的元素修改为指定的值，返回修改前的值</code></pre><h5 id="D：获取功能"><a href="#D：获取功能" class="headerlink" title="D：获取功能"></a>D：获取功能</h5><pre><code>int indexOf(Object o):返回指定元素在集合中第一次出现的索引Object get(int index):获取指定位置的元素ListIterator(int fromIndex,int toIndex):截取集合</code></pre><h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><p>set接口下的元素无序，不可以重复。其下面分为HashSet和TreeSet。</p><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><p>底层数据结构是哈希表，线程不安全，效率高。<br>保证唯一性依赖两个方法：hashCode()和equals()。<br>顺序：<br>     判断hashCode()值是否相同。<br>     相同：继续走equals()，看返回值<br>           如果true：就不添加到集合<br>           如果false：就添加到集合<br>     不同：就添加到集合</p><h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><p>底层数据结构是二叉树，线程不安全，效率高。<br>保证元素唯一性是根据返回值是否为0.<br>保证排序的两种方式：  </p><ol><li>自然排序（元素具备比较性）：实现Comparable接口</li><li>比较排序（集合具备比较性）：实现Comparable接口</li></ol><p>参考资料：<a href="https://blog.csdn.net/haovip123/article/details/45423683" target="_blank" rel="noopener">https://blog.csdn.net/haovip123/article/details/45423683</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;集合概述&quot;&gt;&lt;a href=&quot;#集合概述&quot; class=&quot;headerlink&quot; title=&quot;集合概述&quot;&gt;&lt;/a&gt;集合概述&lt;/h3&gt;&lt;p&gt;Java是一种面向对象的语言，如果要针对多个对象进行操作，就必须对多个对象进行存储。而数组长度固定，不能满足变化的要求。所以
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java内部类(4)</title>
    <link href="http://yoursite.com/2018/03/26/2018-03-26-%E5%86%85%E9%83%A8%E7%B1%BB4/"/>
    <id>http://yoursite.com/2018/03/26/2018-03-26-内部类4/</id>
    <published>2018-03-26T10:39:00.000Z</published>
    <updated>2018-04-22T09:52:09.643Z</updated>
    
    <content type="html"><![CDATA[<p>Java四种内部类使用细节。</p><h3 id="静态内部类（内部类中最简单的形式）"><a href="#静态内部类（内部类中最简单的形式）" class="headerlink" title="静态内部类（内部类中最简单的形式）"></a>静态内部类（内部类中最简单的形式）</h3><ol><li>声明在类体部，方法体外，并且使用static修饰的内部类</li><li>访问特点可以类比静态变量和静态方法</li><li>脱离外部类的实例独立创建<br>在外部类的外部创建内部类的实例：new Outer.Inner();<br>在外部类的内部创建内部类的实例：new Inner();  </li><li>静态内部类体部可以直接访问外部类中所有的静态成员，包含私有</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class StaticInnerTest &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">StaticOuter.StaticInner si = new StaticOuter.StaticInner();</span><br><span class="line">si.test2();</span><br><span class="line">System.out.println(&quot;si.b = &quot;+si.b);</span><br><span class="line">System.out.println(&quot;si.a = &quot;+si.a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class StaticOuter&#123;</span><br><span class="line">private int a = 100;</span><br><span class="line">private static int b = 150;</span><br><span class="line">public static void test() &#123;</span><br><span class="line">System.out.println(&quot;Outer static test...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void test2() &#123;</span><br><span class="line">System.out.println(&quot;Outer instabce test...&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class StaticInner&#123;</span><br><span class="line">public int a = 200;</span><br><span class="line">static int b = 300;</span><br><span class="line">public static void test() &#123;</span><br><span class="line">System.out.println(&quot;Inner static test...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void test2() &#123;</span><br><span class="line">System.out.println(&quot;Inner instabce test...&quot;);</span><br><span class="line">StaticOuter.test();</span><br><span class="line">new StaticOuter().test2();</span><br><span class="line">System.out.println(&quot;StaticOuter.b = &quot;+StaticOuter.b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员内部类（实例内部类）"><a href="#成员内部类（实例内部类）" class="headerlink" title="成员内部类（实例内部类）"></a>成员内部类（实例内部类）</h3><ol><li>没有static修饰的内部类</li><li>在成员内部类中不允许出现静态变量和静态方法的声明，static只能用在静态常量的声明上</li><li>成员内部类中可以访问外部类中所有的成员（变量、方法），包含私有成员，如果在内部类中定义有和外部类同名的实例变量，访问：OuterClass.this.outerMember;</li><li>构建内部类的实例，要求必须外部类的实例先存在<br>外部类的外部/外部类的静态方法：new Outer().new Inner();<br>外部类的实例方法：new Inner(); this.new Inner();</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class MemberInnerTest &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">MemberOuter mo = new MemberOuter();</span><br><span class="line">mo.setS1(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MemberOuter&#123;</span><br><span class="line">private String s1 = &quot;Outer InstanceMar&quot;;</span><br><span class="line">private String s2 = &quot;OuterStatic s2&quot;;</span><br><span class="line">public void setS1(String s1) &#123;</span><br><span class="line">this.s1 = s1;</span><br><span class="line">new MemberOuter().new MemberInner();</span><br><span class="line">this.new MemberInner();//此时MemberOuter已经实例化，所以可以使用this</span><br><span class="line">new MemberInner().test2();</span><br><span class="line">&#125;</span><br><span class="line">public static void test2() &#123;</span><br><span class="line">new MemberOuter().new MemberInner();</span><br><span class="line">/*</span><br><span class="line"> * this.new MemberInner();</span><br><span class="line"> * 此时MemberOuter没有实例化完成，所以不能使用this</span><br><span class="line"> * static 是在MemberOuter构造器前使用，所以此时不能使用this</span><br><span class="line"> */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MemberInner&#123;</span><br><span class="line">String s1 = &quot;Inner InstanceMae&quot;;</span><br><span class="line">static final String s4 = &quot;static final MemberInner&quot;;</span><br><span class="line">void test2() &#123;</span><br><span class="line">System.out.println(&quot; s1 = &quot;+s1);</span><br><span class="line">System.out.println(&quot; Outter MemberOuter.this.s1 = &quot;+MemberOuter.this.s1);</span><br><span class="line">System.out.println(&quot; s2 = &quot;+s2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><ol><li>定义在方法体甚至比方法体更小的代码块中</li><li>类比局部变量</li><li>局部内部类是所有内部类中最少使用的一种形式</li><li>局部内部类可以访问的外部类成员根据所在方法体不同<br>如果在静态方法中：可以访问外部类的所有静态成员，包含私有<br>如果在实例方法中：可以访问外部类的所有成员，包含私有<br>局部内部类可以访问所在方法中定义的局部变量，但是要求局部变量必须用final修饰  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class LocalInnerTest &#123;  </span><br><span class="line">  </span><br><span class="line">    private int a = 1;  </span><br><span class="line">    private static int b = 2;  </span><br><span class="line">  </span><br><span class="line">    public void test() &#123;  </span><br><span class="line">        final int c = 3;  </span><br><span class="line">        class LocalInner &#123;  </span><br><span class="line">            public void add1() &#123;  </span><br><span class="line">                System.out.println(&quot;a= &quot; + a);  </span><br><span class="line">                System.out.println(&quot;b= &quot; + b);  </span><br><span class="line">                System.out.println(&quot;c= &quot; + c);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        new LocalInner().add1();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    static public void test2() &#123;  </span><br><span class="line">        final int d = 5;  </span><br><span class="line">        class LocalInner2 &#123;  </span><br><span class="line">            public void add1() &#123;  </span><br><span class="line">                // System.out.println(&quot;a= &quot; + a);  </span><br><span class="line">                System.out.println(&quot;b= &quot; + b);  </span><br><span class="line">                System.out.println(&quot;c= &quot; + d);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        new LocalInner2().add1();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String args[]) &#123;  </span><br><span class="line">  </span><br><span class="line">        // LocalInnerTest() lc = new LocalInnerTest();  </span><br><span class="line">        new LocalInnerTest().test2();  </span><br><span class="line">        new LocalInnerTest().test();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><ol><li>没有名字的局部内部类</li><li>没有class、interface、implements、extends关键字</li><li>没有构造器</li><li>一般隐式的集成某一个父类或者实现某一个接口</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">**  </span><br><span class="line"> * @author gress 匿名内部类,我只会使用一次的类  </span><br><span class="line"> *   </span><br><span class="line"> * 就假如我想吃一个泡面,但我不可能建一个厂,制造一个流水线,生产一包泡面之后就在也不去使用这个泡面厂了  </span><br><span class="line"> * 所以这里引申出匿名内部类 ,而我们建立的泡面厂就像这里构建的一个类Pencil 铅笔类一样  </span><br><span class="line"> */  </span><br><span class="line">interface Pen &#123;  </span><br><span class="line">    public void write();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class  Pencil implements Pen &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void write() &#123;  </span><br><span class="line">        //铅笔 的工厂  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class Person &#123;  </span><br><span class="line">    public void user(Pen pen) &#123;  </span><br><span class="line">        pen.write();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">public class AnyInnerTest &#123;  </span><br><span class="line">    public static void main(String args[]) &#123;  </span><br><span class="line">        Person guo = new Person();  </span><br><span class="line">          </span><br><span class="line">        guo.user(new Pen() &#123;  </span><br><span class="line">            @Override  </span><br><span class="line">            public void write() &#123;  </span><br><span class="line">                System.out.println(&quot;写子&quot;);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文章：<a href="https://blog.csdn.net/qq_33599978/article/details/70880803" target="_blank" rel="noopener">https://blog.csdn.net/qq_33599978/article/details/70880803</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java四种内部类使用细节。&lt;/p&gt;
&lt;h3 id=&quot;静态内部类（内部类中最简单的形式）&quot;&gt;&lt;a href=&quot;#静态内部类（内部类中最简单的形式）&quot; class=&quot;headerlink&quot; title=&quot;静态内部类（内部类中最简单的形式）&quot;&gt;&lt;/a&gt;静态内部类（内部类中最简单
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java内部类(3)</title>
    <link href="http://yoursite.com/2018/03/26/2018-03-26-%E5%86%85%E9%83%A8%E7%B1%BB3/"/>
    <id>http://yoursite.com/2018/03/26/2018-03-26-内部类3/</id>
    <published>2018-03-26T09:12:00.000Z</published>
    <updated>2018-04-22T09:53:22.927Z</updated>
    
    <content type="html"><![CDATA[<p>由于每个类都是产生一个.class文件，其中包含了如何创建该类型的对象的全部信息（此信息产生一个“meta-class”，叫做Class对象）。内部类也必须产生一个.class文件以包含它们的Class对象信息。这些类文件的命名有严格的队则：<strong>外围类的名字，加上“$”，再加上内部类的名字</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class LocalInnerClass &#123;</span><br><span class="line"></span><br><span class="line">private int count = 0;</span><br><span class="line">Counter getCounter(final String name) &#123;</span><br><span class="line">class LocalCounter implements Counter&#123;</span><br><span class="line">public LocalCounter() &#123;</span><br><span class="line">System.out.println(&quot;LocalCounter&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public int next() &#123;</span><br><span class="line">System.out.println(name);</span><br><span class="line">return count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return new LocalCounter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Counter getCounter2(final String name) &#123;</span><br><span class="line">return new Counter() &#123;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;Counter()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public int next() &#123;</span><br><span class="line">System.out.println(name);</span><br><span class="line">return count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Counter&#123;</span><br><span class="line">int next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面程序的生成的.class文件包括：   </p><p>Counter.class<br>LocalInnerClass$1.class<br>LocalInnerClass$1LocalCounter.class<br>LocalInnerClass </p><p>如果内部类是匿名的，编译器会简单地产生一个数字作为其标识符。如果内部类是嵌套在别的内部类之中，只需直接将它们的名字加在其外围类标识符与“$”的后面。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于每个类都是产生一个.class文件，其中包含了如何创建该类型的对象的全部信息（此信息产生一个“meta-class”，叫做Class对象）。内部类也必须产生一个.class文件以包含它们的Class对象信息。这些类文件的命名有严格的队则：&lt;strong&gt;外围类的名字，加
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java内部类(2)</title>
    <link href="http://yoursite.com/2018/03/26/2018-03-26-%E5%86%85%E9%83%A8%E7%B1%BB2/"/>
    <id>http://yoursite.com/2018/03/26/2018-03-26-内部类2/</id>
    <published>2018-03-26T07:43:00.000Z</published>
    <updated>2018-04-22T09:54:15.714Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用-this"><a href="#使用-this" class="headerlink" title="使用.this"></a>使用.this</h3><p>如果你需要声称对外部类对象的引用，可以使外部类的名字后面紧跟圆点和this，这样产生的引用自动的具有正确的类型，这一点在编译期就被知晓并受到检查，因此没有任何运行时开销。下面的例子展示了如何使用this:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class DotThis &#123;</span><br><span class="line"></span><br><span class="line">void f() &#123;</span><br><span class="line">System.out.println(&quot;DotThis.f()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public class Inner&#123;</span><br><span class="line">public DotThis outer() &#123;</span><br><span class="line">return DotThis.this;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Inner inner() &#123;</span><br><span class="line">return new Inner();</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">DotThis dt = new DotThis();</span><br><span class="line">DotThis.Inner dti = dt.inner();</span><br><span class="line">dti.outer().f();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用-new"><a href="#使用-new" class="headerlink" title="使用.new"></a>使用.new</h3><p>有时你可能想告知某些其它对象，去创建其某个内部类的对象。要实现此目的，你必须在new表达式中提供对其他外部类对象的引用，这时需要用new语法，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class DotNew &#123;</span><br><span class="line">public class Inner&#123;&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">DotNew dn = new DotNew();</span><br><span class="line">DotNew.Inner dni = dn.new Inner();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;使用-this&quot;&gt;&lt;a href=&quot;#使用-this&quot; class=&quot;headerlink&quot; title=&quot;使用.this&quot;&gt;&lt;/a&gt;使用.this&lt;/h3&gt;&lt;p&gt;如果你需要声称对外部类对象的引用，可以使外部类的名字后面紧跟圆点和this，这样产生的引用自动的具有
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java为什么要设置环境变量</title>
    <link href="http://yoursite.com/2018/03/23/2018-03-23-java%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/2018/03/23/2018-03-23-java设置环境变量/</id>
    <published>2018-03-23T01:55:00.000Z</published>
    <updated>2018-04-22T09:55:24.742Z</updated>
    
    <content type="html"><![CDATA[<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>环境变量：Environment variable<br>变量：就是可以随意给其赋值的存储单元。<br>环境：可以把操作系统当做一个最大的软件，其他软件比如office、LOL、JVM等都是运行在这个大软件内的小软件。那么环境就是指这个操作系统。<br>环境变量：就是指操作系统中某个软件中变量，也就是：全局变量。<br>作用：变量在任何程序中的作用都是被赋值/被使用！这个全局变量操作系统可以使用，其它小软件也可以使用。</p><h3 id="java环境变量设置"><a href="#java环境变量设置" class="headerlink" title="java环境变量设置"></a>java环境变量设置</h3><p>环境变量大体上是给操作系统的直接上层程序使用的，比如Linux中的shell、.sh文件，Windows中的cmd、.bat文件。<br><strong>PATH</strong><br>这是其实是操作系统用的，用来指定操作系统需要使用到的程序的位置。对java来说，通常需要把jdk的bin目录放入path中，这样就可以在任意目录下使用bin下面的javac.exe、java.exe等。<strong>这个变量一定要保证将JRE/jdk纳入其中（这里其实不严谨，你可以把javaw.exe等这类文件复制一份放到任意一个path路径下，不一定是jre/jdk也行），这样很多java程序才能启动，比如eclipse。</strong><br><strong>JAVA_HOME</strong><br>JAVA_HOME:是一个约定，通常它指的是jdk目录。如果需要jdk的话，大部分程序会默认去环境变量中取JAVA_HOME这个变量。比如，Tomcat的.bat/.sh文件中就会默认去取JAVA_HOME来用。<strong>所以，这个变量最需要设置。设置它，可保万无一失。</strong><br><strong>JRE_HOME</strong><br>同样，这也是一个约定的变量，通常指JRE目录。<strong>其实大部分Java程序不需要jdk，而是只需要其子集JRE，</strong>所以也有很多程序会去取这个变量来用。<br>例如Tomcat中某些.bat文件中这样说到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;code class=&quot;language-bat hljs vbnet&quot;&gt;rem   JAVA_HOME       Must point at your Java Development Kit installation.</span><br><span class="line">rem                   Using JRE_HOME instead works as well.</span><br><span class="line">rem</span><br><span class="line">rem   JRE_HOME        Must point at your Java Runtime installation.</span><br><span class="line">rem                   Defaults to JAVA_HOME if empty. If JRE_HOME and JAVA_HOME</span><br><span class="line">rem                   are both set, JRE_HOME is used.&lt;/code&gt;</span><br></pre></td></tr></table></figure></p><p>大意就是，Tomcat去取这两个变量，只要任意一个不为空就行，都不为空就用JRE_HOME。因为Tomcat不需要jdk中的工具，它只是运行Java程序而已。<br><strong>这个变量如果你明确知道应用程序只需要设置这个就行（比如上面Tomcat的注释），那么它可以代替JAVA_HOME，且最好就用这个。</strong><br><strong>CLASSPATH</strong><br>基本上，这个变量指的是：AppClassLoader加载的class路径。<br>这个变量就跟所有java写的程序有关，不光其它Java程序会用到（比如Tomcat在某些情况会用），我们写的java程序也用到了。但其实，如果用eclipse的话你还是只需要点击一下BuildPath就行了，还是没有让你显式的用XXXX=XXXX这种方式。不过你用command line来运行java程序的话通常会用到classpath。<br>可以在Java程序中用代码获取到当前classpath的内容，像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;code class=&quot;language-java hljs &quot;&gt;System.getProperty(&quot;java.class.path&quot;)</span><br><span class="line">//输出是String内容是你项目的class文件的根目录 + 你引用的jar包们的地址。类似这样</span><br><span class="line">E:\test1\target\classes;E:\Java\Program Files\.m2\repository\mysql\mysql-connector-java\5.1.38\mysql-connector-java-5.1.38.jar...&lt;/code&gt;</span><br></pre></td></tr></table></figure></p><p>所以，这个变量在使用IDE进行开发的情况下，通常不需要手动设置，只需要按常规IDE使用步骤（比如Build path）IDE会帮我们做。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME:C:\Program Files\Java\jdk-9.0.1              (按照自己的jdk路径)  </span><br><span class="line">CLASSPATH:.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar;   (不要忘记前面的.)  </span><br><span class="line">Path:%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin</span><br></pre></td></tr></table></figure><ul><li>JAVA_HOME主要是给后面两个用的；</li><li>CLASSPATH指定的是默认的类库的位置；</li><li>PATH是让java的bin加入到系统路径中，这样命令行或其它程序就可以调用java、javac、javaw等命令了（到处可以使用这些命令）。</li></ul><p>参考：<a href="https://www.2cto.com/kf/201605/506454.html" target="_blank" rel="noopener">https://www.2cto.com/kf/201605/506454.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;环境变量&quot;&gt;&lt;a href=&quot;#环境变量&quot; class=&quot;headerlink&quot; title=&quot;环境变量&quot;&gt;&lt;/a&gt;环境变量&lt;/h3&gt;&lt;p&gt;环境变量：Environment variable&lt;br&gt;变量：就是可以随意给其赋值的存储单元。&lt;br&gt;环境：可以把操作系统
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>javac不是内部或外部命令</title>
    <link href="http://yoursite.com/2018/03/23/2018-03-23-javac%E4%B8%8D%E6%98%AF%E5%86%85%E9%83%A8%E6%88%96%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/03/23/2018-03-23-javac不是内部或外部命令/</id>
    <published>2018-03-23T01:17:00.000Z</published>
    <updated>2018-04-22T09:55:52.036Z</updated>
    
    <content type="html"><![CDATA[<p>首先将JAVA_HOME、CLASSPATH、Path配置好，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME:C:\Program Files\Java\jdk-9.0.1              (按照自己的jdk路径)  </span><br><span class="line">CLASSPATH:.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar;   (不要忘记前面的.)  </span><br><span class="line">Path:%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin</span><br></pre></td></tr></table></figure></p><p>如果运行javac不是内部或者外部命令，就将Path配置为全路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jdk-9.0.1\bin</span><br><span class="line">C:\Program Files\Java\jre-9.0.1\bin</span><br></pre></td></tr></table></figure></p><p>这样就可以使用javac命令了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先将JAVA_HOME、CLASSPATH、Path配置好，&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;spa
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java内部类(1)</title>
    <link href="http://yoursite.com/2018/03/22/2018-03-22-java%E5%86%85%E9%83%A8%E7%B1%BB1/"/>
    <id>http://yoursite.com/2018/03/22/2018-03-22-java内部类1/</id>
    <published>2018-03-22T07:43:00.000Z</published>
    <updated>2018-04-22T10:01:04.871Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是内部类"><a href="#什么是内部类" class="headerlink" title="什么是内部类"></a>什么是内部类</h3><p>内部类，顾名思义就是在内部的类就是内部类，可以是在类的内部，也可以是在接口的内部。<br>内部类又分为以下几种：<br>(1) 普通内部类<br>(2) 匿名内部类<br>(3) 嵌套内部类  </p><ol><li>普通内部类<br>普通内部类就是在一个类内定义一个普通的类（也可以是定义一个类的方法内定义一个类，称为局部内部类），如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Parcel1 &#123;</span><br><span class="line"></span><br><span class="line">class Contents&#123;</span><br><span class="line">private int i = 11;</span><br><span class="line">public int value() &#123;</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Destination&#123;</span><br><span class="line">private String label;</span><br><span class="line">Destination(String whereTo)&#123;</span><br><span class="line">label = whereTo;</span><br><span class="line">&#125;</span><br><span class="line">String readLabel() &#123;</span><br><span class="line">return label;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Destination to(String s) &#123;</span><br><span class="line">return new Destination(s);</span><br><span class="line">&#125;</span><br><span class="line">public Contents contents() &#123;</span><br><span class="line">return new Contents();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void ship(String dest) &#123;</span><br><span class="line">Contents c = new Contents();</span><br><span class="line">Destination d = new Destination(dest);</span><br><span class="line">System.out.println(d.readLabel());</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Parcel1 p = new Parcel1();</span><br><span class="line">p.ship(&quot;Tasmania&quot;);</span><br><span class="line">Parcel1 q = new Parcel1();</span><br><span class="line">Parcel1.Contents c = q.contents();</span><br><span class="line">Parcel1.Destination d = q.to(&quot;Borneo&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>从上面的代码可以看出，如果想在外部类的非静态方法之外的任意位置创建某个内部类的对象，必须按照这个格式：OuterClassName.InnerClassName。<br>当生成一个内部类对象时，此对象与制造它的外围对象之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何特殊条件。此外，内部类还拥有外围类的所有元素的访问权（即使是private）。我自己变成测试，内部类的对象不能访问其外围对象的成员，但是在内部类内可以访问其外围类的成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class Sequence &#123;</span><br><span class="line">private Object[] items;</span><br><span class="line">private int next = 0;</span><br><span class="line">public Sequence(int size) &#123;</span><br><span class="line">items = new Object[size];</span><br><span class="line">&#125;</span><br><span class="line">public void add(Object x) &#123;</span><br><span class="line">if(next &lt; items.length) &#123;</span><br><span class="line">items[next++] = x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">private class SequenceSelector implements Selector&#123;</span><br><span class="line">private int i = 0;</span><br><span class="line">public boolean end() &#123;</span><br><span class="line">return i == items.length;</span><br><span class="line">&#125;</span><br><span class="line">public Object current() &#123;</span><br><span class="line">return items[i];</span><br><span class="line">&#125;</span><br><span class="line">public void next() &#123;</span><br><span class="line">if(i&lt;items.length) &#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public Selector selector() &#123;</span><br><span class="line">return new SequenceSelector();</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Sequence sequence = new Sequence(10);</span><br><span class="line">for(int i = 0; i &lt; 10; i++) </span><br><span class="line">sequence.add(Integer.toString(i));</span><br><span class="line">Selector selector = sequence.selector();</span><br><span class="line">while(!selector.end()) &#123;</span><br><span class="line">System.out.println(selector.current() + &quot; &quot;);</span><br><span class="line">selector.next();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Selector&#123;</span><br><span class="line">boolean end();</span><br><span class="line">Object current();</span><br><span class="line">void next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>总结：</strong><br>(1) 内部类自动拥有外围类所有成员（包括private成员）的访问权限；<br>(2) 在外位类的静态方法中创建内部类的对象需要指明其具体类型，要按照格式：OuterClassName.InnerClassName</p><ol start="2"><li>匿名内部类<br>匿名内部类就是没有类名的类，听起来很奇怪，举个例子：  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Parcel7 &#123;</span><br><span class="line">public Contents contents() &#123;</span><br><span class="line">return new Contents() &#123;</span><br><span class="line">private int i = 11;</span><br><span class="line">public int value() &#123;</span><br><span class="line">System.out.println(&quot;i:&quot;+i);</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Parcel7 p = new Parcel7();</span><br><span class="line">Contents c = p.contents();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Contents&#123;</span><br><span class="line">int value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的方法contengs()中，将返回值的生成与表示这个返回值的类的定义结合在一起。另外这个类是匿名的，看起来像是你正要创建一个C对象，但是然后你却说：“等一等，我想在这里插入一个类的定义。”定义一个匿名类，要么继承一个类（或者抽象类），要么实现一个接口。</p><ul><li>如果定义一个匿名类，并且希望使用一个在其外部定义的对象，那么编译器会要求其参数是final的。</li></ul><ol start="3"><li>嵌套类<br>如果不需要内部类对象与外围类对象之间有联系，那么可以将内部类声明为static。想要理解static应用于内部类是的含义，就必须记住，普通的内部类对象隐式地保存了一个引用，指向创建它的外围类对象。然而，当内部类是static时，就不是这样了。嵌套类意味着：  </li></ol><ul><li>要创建嵌套类的对象，并不需要其外围类的对象。</li><li>不能从嵌套类的对象中访问非静态的外围类对象。  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class F&#123;</span><br><span class="line">private static class G implements C&#123;</span><br><span class="line">private String str = &quot;static class G&quot;;</span><br><span class="line">public void run()&#123;</span><br><span class="line">System.out.println(&quot;run &quot;+str);</span><br><span class="line">&#125;</span><br><span class="line">public void speak()&#123;</span><br><span class="line">System.out.println(&quot;speak &quot;+str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>嵌套类没有链接到外围类对象的this引用，这使得它像一个static方法。</li><li>脱离外部耒的实例独立创建，在外部类的外部创建内部类的实例：new Outer.Inner();<br>在外部类的内部创建内部类的实例：new Inner();</li><li>静态内部类可以直接访问外部类中所有的静态成员，包含私有。</li></ul><h3 id="为什么需要内部类"><a href="#为什么需要内部类" class="headerlink" title="为什么需要内部类"></a>为什么需要内部类</h3><p>(1) 内部类提供了更好的封装，只有外部类才能访问内部类；<br>(2) 内部类可以独立继承一个接口，不受外部类是否是否继承接口的影响；<br>(3) 内部类中的方法和属性即使是外部类也不能访问，相反内部类可以直接访问外部类的属性和方法，即使是private；<br>(4) 利于回调函数的编写。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是内部类&quot;&gt;&lt;a href=&quot;#什么是内部类&quot; class=&quot;headerlink&quot; title=&quot;什么是内部类&quot;&gt;&lt;/a&gt;什么是内部类&lt;/h3&gt;&lt;p&gt;内部类，顾名思义就是在内部的类就是内部类，可以是在类的内部，也可以是在接口的内部。&lt;br&gt;内部类又分为以下几
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>金银价格与美联储加息之3月22</title>
    <link href="http://yoursite.com/2018/03/22/2018-03-22-%E9%BB%84%E9%87%91%E7%99%BD%E9%93%B6%E4%BB%B7%E6%A0%BC%E4%B8%8E%E7%BE%8E%E8%81%94%E5%82%A83%E6%9C%88%E5%8A%A0%E6%81%AF/"/>
    <id>http://yoursite.com/2018/03/22/2018-03-22-黄金白银价格与美联储3月加息/</id>
    <published>2018-03-22T01:25:00.000Z</published>
    <updated>2018-04-22T10:00:23.054Z</updated>
    
    <content type="html"><![CDATA[<p>2018年3月22日凌晨，美联储不出预料的加息25个基点，完全符合预期。金银价格在加息时几乎没有大的波动，因为市场已经预期到美联储会加息，所以在加息之前，市场已经做出反应。相反，金银价格在美联储宣布加息时金银的价格出现了反弹上升。<br>金价走势如下：<br><img src="/images/posts/huangjin.jpg" alt="黄金价格波动"><br>白银T+D价格走势如下：<br><img src="/images/posts/baiyintd.jpg" alt="黄金价格波动"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018年3月22日凌晨，美联储不出预料的加息25个基点，完全符合预期。金银价格在加息时几乎没有大的波动，因为市场已经预期到美联储会加息，所以在加息之前，市场已经做出反应。相反，金银价格在美联储宣布加息时金银的价格出现了反弹上升。&lt;br&gt;金价走势如下：&lt;br&gt;&lt;img sr
      
    
    </summary>
    
      <category term="economy" scheme="http://yoursite.com/categories/economy/"/>
    
    
      <category term="economy" scheme="http://yoursite.com/tags/economy/"/>
    
  </entry>
  
  <entry>
    <title>java抽象类和接口</title>
    <link href="http://yoursite.com/2018/03/19/2018-03-19-java%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2018/03/19/2018-03-19-java抽象类和接口/</id>
    <published>2018-03-19T07:43:00.000Z</published>
    <updated>2018-04-22T10:02:30.736Z</updated>
    
    <content type="html"><![CDATA[<p>在java中，可以通过两种方式来体现OOP的抽象：接口和抽象类。这两者有太多相似的地方，又有太多不同的地方。</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>在了解抽象类之前，先了解一下抽象方法。抽象方法是一种特殊的方法，它只有声明，而没有具体的实现。抽象方法的实现各式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abstract void fun();</span><br></pre></td></tr></table></figure></p><p>抽象方法必须用abstract关键字进行修饰。如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用abstract关键字修饰。<strong>因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。</strong><br><strong>下面要注意一个问题：在《java编程思想》一书中，将抽象类定义为“包含抽象方法的类”，但是后面发现如果一个类不包含抽象方法，只是用abstract修饰的话也是抽象类。也就是说抽象类不一定必须含有抽象方法抽象方法。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[public] abstract class ClassName&#123;</span><br><span class="line">abstract void fun();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从这里可以看出抽象类就是为了继承而存在的，如果定义了一个抽象类而不去继承，那么等于白白创建了这个抽象类，因为不能用它来做任何事。对于一个父类，如果它的某个方法在父类中实现出来没有任何意义，必须根据子类的实际需求来进行不同的实现，那么就可以将这个方法声明为abstract方法，此时这个类也就称为abstract类了。<br>包含抽象方法的类称为抽象类，但<strong>并不意味着抽象类中只有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法。</strong><br>注意，抽象类和普通类主要有三点区别：<br>(1) 抽象方法必须为public或者protected（如果为private则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public；<br>(2) 抽象类不能创建对象；<br>(3) 如果一个类继承于抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。<br>在其它方面抽象类和普通类没有什么区别。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口，英文称作interface，在软件工程中，接口泛指供别人调用的方法或函数。从这里我们可以体会到java语言设计者的初衷，它是对行为的抽象。在java中定义一个接口的形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[public] interface InterfaceName&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接口中可以含有变量和方法。但是要注意，接口中的变量会被隐式地指定为public static final（并且只能是public static final变量，用private修饰会报编译错误），而方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其它关键字，比如private、protected、static、final等修饰会报编译错误），并且接口中所有的方法不能有具体实现，也就是说，接口中的方法必须是抽象方法。从这里隐约可以看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加抽象，并且在一般情况下不在接口中定义变量。<br>要让一个类遵循某组特定的接口需要使用implements关键字，具体格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class ClassName implements Interface1, Interface2,[....]&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，允许一个类遵循多个特定的接口。如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。</p><h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><ol><li><p>语法层面上的区别<br>(1) 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract方法；<br>(2) 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型；<br>(3) 抽象类中可以有静态代码块和静态方法，而接口中不能含有静态代码块和静态方法；<br>(4) 一个类只能继承一个抽象类，而一个类可以实现多个接口。  </p></li><li><p>设计层面上的区别<br>(1) 抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但它们有一个共性，就是会飞。那么在设计的时候，将飞机可以设计为一个类Airplane，将鸟设计为一个类Bird，但是不能讲飞行这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将飞行设计为一个接口Fly，包含方法fly()，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同类型的飞机，比如战斗机、民用飞机，直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个“是不是”的关系，而接口实现则是“有没有”的关系。如果一个类继承了某个抽象类，则子类必须是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。<br>(2)设计层面上，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单的例子，大家都用过PPT里面的模板，如果用模板A设计了PPT B和PPT C，PPT B和PPT C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改变模板A就可以了，不需要重新对PPT B和PPT C进行改动。而辐射式设计，比如某个电梯都安装了某种警报器，一旦要更新警报器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，则可以在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则实现这个接口的类都需要进行相应的改动。  </p></li></ol><p>下面看一个网上流传最广泛的例子：门和警报的例子：门都有open()和close()两个动作，此时我们可以通过抽象类和接口来定义这个抽象概念：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abstract class Door&#123;</span><br><span class="line">public abstract void open();</span><br><span class="line">public abstract void close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Door&#123;</span><br><span class="line">public abstract void open();</span><br><span class="line">public abstract void close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是现在如果我们需要门具有警报alarm()的功能，那么该如何实现呢？下面提供两种思路：<br>(1) 将这三个功能都放在抽象类中，但是这样所有继承这个抽象类的的子类都具有了警报功能，但是有的门并不一定具有警报功能；<br>(2) 将三个功能都放在接口中，需要用到警报的类就实现这个接口中的open()和close()，也许这个类根本就不需要open()和close()这两个功能，比如火灾警报器。<br>从这里可以看出，Door的open()和close()和alarm()根本就属于两个不同范畴的内的行为，open()和close()属于门本身固有行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法单独将警报设计为一个接口，包含alarm()行为，Door设计为一个单独的抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm&#123;</span><br><span class="line">void alarm();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Door&#123;</span><br><span class="line">void open();</span><br><span class="line">void close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AlarmDoor extends Door implements Alarm&#123;</span><br><span class="line">void open()&#123;</span><br><span class="line">//...</span><br><span class="line">&#125;</span><br><span class="line">void close()&#123;</span><br><span class="line">//...</span><br><span class="line">&#125;</span><br><span class="line">void alarm()&#123;</span><br><span class="line">//...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考资料：<a href="http://www.importnew.com/18780.html" target="_blank" rel="noopener">http://www.importnew.com/18780.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在java中，可以通过两种方式来体现OOP的抽象：接口和抽象类。这两者有太多相似的地方，又有太多不同的地方。&lt;/p&gt;
&lt;h3 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h3&gt;&lt;p&gt;在了解抽
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java多态</title>
    <link href="http://yoursite.com/2018/03/18/2018-03-19-java%E5%A4%9A%E6%80%81/"/>
    <id>http://yoursite.com/2018/03/18/2018-03-19-java多态/</id>
    <published>2018-03-18T12:03:00.000Z</published>
    <updated>2018-04-22T10:01:49.271Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象的三大特征：封装、继承、多态。从一定角度来看，封装和继承几乎都是为多态而准备的。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>多态：指允不同类的对象对同一消息做出相应。即同一消息可以根据发送对象的不同而采用多种不同的方式。（发送消息就是函数调用）</p><h3 id="实现多态的技术"><a href="#实现多态的技术" class="headerlink" title="实现多态的技术"></a>实现多态的技术</h3><p>实现多态的技术：动态绑定，是指在执行期间判断所引用对象的实际类型，根据实际的类型调用其相应的方法。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>消除类型之间的耦合关系。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>现实中，关于多态的例子不胜枚举。比如按下F1键这个动作，如果当前在Flash界面下弹出的就是AS3帮助文档；如果当前在word下弹出的就是Word帮助；在Windows下弹出的就是windows帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。</p><h3 id="多态存在的三个必要条件"><a href="#多态存在的三个必要条件" class="headerlink" title="多态存在的三个必要条件"></a>多态存在的三个必要条件</h3><p>要求大家做梦的时候都要背出来，多态存在的三个条件：</p><ul><li>要有继承</li><li>要有重写</li><li>父类引用指向子类对象</li></ul><h3 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h3><ol><li>可替换性(substitutability)：多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其它任何圆形几何体，如圆环，也同样工作。</li><li>可扩充性(extensibility)：多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其它特性的运行和操作。实际上增加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多台基础上，很容易增加球体的多态性。</li><li>接口性(interface-ability)：多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现。</li><li>灵活性(flexibility)：它在应用中体现了灵活多样的操作，提高了使用效率。</li><li>简化性(simpllicity)：多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>面向对象编程有三大特性：封装、继承、多态。  </p><p>封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。  </p><p>继承是为了重用父类代码。两个类若存在IS-A的关系就可以使用继承。，同时继承也为实现多态做了铺垫。那么什么是多态呢？多态的实现机制又是什么？请看我一一为你揭开：  </p><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。  </p><p>比如你是一个酒神，对酒情有独钟。某日回家发现桌上有几个杯子里面都装了白酒，从外面看我们是不可能知道这是些什么酒，只有喝了之后才能够猜出来是何种酒。你一喝，这是剑南春、再喝这是五粮液、再喝这是酒鬼酒….在这里我们可以描述成如下：  </p><p>酒 a = 剑南春  </p><p>酒 b = 五粮液  </p><p>酒 c = 酒鬼酒  </p><p>…</p><p>这里所表现的的就是多态。剑南春、五粮液、酒鬼酒都是酒的子类，我们只是通过酒这一个父类就能够引用不同的子类，这就是多态——我们只有在运行的时候才会知道引用变量所指向的具体实例对象。  </p><p>诚然，要理解多态我们就必须要明白什么是“向上转型”。在继承中我们简单介绍了向上转型，这里就在啰嗦下：在上面的喝酒例子中，酒（Win）是父类，剑南春（JNC）、五粮液（WLY）、酒鬼酒（JGJ）是子类。我们定义如下代码：  </p><p>JNC a = new  JNC();  </p><p>对于这个代码我们非常容易理解无非就是实例化了一个剑南春的对象嘛！但是这样呢？  </p><p>Wine a = new JNC();  </p><p>在这里我们这样理解，这里定义了一个Wine 类型的a，它指向JNC对象实例。由于JNC是继承与Wine，所以JNC可以自动向上转型为Wine，所以a是可以指向JNC实例对象的。这样做存在一个非常大的好处，在继承中我们知道子类是父类的扩展，它可以提供比父类更加强大的功能，如果我们定义了一个指向子类的父类引用类型，那么它除了能够引用父类的共性外，还可以使用子类强大的功能。  </p><p><strong>静态方法不具有多态性；构造器实际上是static方法，只不过该static声明是隐式的。</strong></p><p>参考：<a href="http://www.importnew.com/20079.html" target="_blank" rel="noopener">http://www.importnew.com/20079.html</a>和<a href="https://www.cnblogs.com/mz-lover/p/4786337.html" target="_blank" rel="noopener">https://www.cnblogs.com/mz-lover/p/4786337.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;面向对象的三大特征：封装、继承、多态。从一定角度来看，封装和继承几乎都是为多态而准备的。&lt;/p&gt;
&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;多态：指允不同类的对象对同一消息做出
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>final关键字</title>
    <link href="http://yoursite.com/2018/03/18/2018-03-18-final%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2018/03/18/2018-03-18-final关键字/</id>
    <published>2018-03-18T07:34:00.000Z</published>
    <updated>2018-04-22T10:06:14.360Z</updated>
    
    <content type="html"><![CDATA[<p>java的final关键字通常指“这是无法改变的”，使用到final的三种情况：变量、方法、类。</p><h2 id="final关键字的基本用法"><a href="#final关键字的基本用法" class="headerlink" title="final关键字的基本用法"></a>final关键字的基本用法</h2><h3 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h3><p>当用final修饰一个类时，表明这个类不能被继承。也就是说，如果你想让一个类不被继承，可以用final来修饰它。final类中的成员变量也可以根据需要设为final，<strong>但是要注意final类中的所有成员方法都会被隐式地指定为final方法</strong>。<br><strong>在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为final。</strong></p><h3 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h3><p>下面摘自《Java编程思想》：<br>“使用final方法的原因有两个。第一个原因是把方法锁定，以防止任何继承类修改它的含义；第二个原因是效率。在早期的Java版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行优化了。”<br>因此，只有在明确禁止该方法在子类中被覆盖的情况下才将方法设置为final的。<br><strong>类的private方法会被隐式地指定为final方法。</strong></p><h3 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h3><p>对于一个final变量，如果是基本数据类型的变量，则其数值一旦在被初始化后便不能更改；如果是引用类型的变量，则其在被初始化后不能再被指向另一个变量了。</p><h2 id="深入理解final关键字"><a href="#深入理解final关键字" class="headerlink" title="深入理解final关键字"></a>深入理解final关键字</h2><h3 id="类的final变量和基本变量有什么区别？"><a href="#类的final变量和基本变量有什么区别？" class="headerlink" title="类的final变量和基本变量有什么区别？"></a>类的final变量和基本变量有什么区别？</h3><p>当用final作用于类的成员变量（注意是成员变量，局部变量只要保证在使用之前被初始化即可）必须在定义是或构造器中进行初始化赋值，而且final变量一旦被初始化之后就不能再被赋值了。<br>看下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">public class void main(String[] args)&#123;</span><br><span class="line">String a = &quot;hello2&quot;;</span><br><span class="line">final String b = &quot;hello&quot;;</span><br><span class="line">String d = &quot;hello&quot;;</span><br><span class="line">String c = b+2;</span><br><span class="line">String e = d+2;</span><br><span class="line">System.out.println(a == c);</span><br><span class="line">System.out.println(a == e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">      true</span><br><span class="line">      false</span><br></pre></td></tr></table></figure><p>为什么第一个结果为true，第二个结果为false？这里面就是final变量和普通变量的区别了，当final是基本数据类型和String类型时，如果在编译期间就知道它的确切值，则编译器会把它当做编译期常量使用。也就是说在用到该final变量的地方，相当于直接访问这个常量，不需要在运行时确定。因此在上面的一段代码中，由于变量b被final修饰，因此会被当做编译器常量，所以在用到b的地方会直接将变量b替换为它的值。而对于变量d的访问需要在运行时通过链接来进行。不过要注意，只有在编译期间能确切知道final变量值的情况下，编译器才会进行这样的优化。比如下面这段代码就不会进行优化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">String a = &quot;hello2&quot;;</span><br><span class="line">final String b = getHello();</span><br><span class="line">String c = b+2;</span><br><span class="line">System.out.println(a == c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static String getHello()&#123;</span><br><span class="line">return &quot;hello&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">      false</span><br></pre></td></tr></table></figure><h3 id="被final修饰的引用变量指向的内容可变吗？"><a href="#被final修饰的引用变量指向的内容可变吗？" class="headerlink" title="被final修饰的引用变量指向的内容可变吗？"></a>被final修饰的引用变量指向的内容可变吗？</h3><p>在上面提到final修饰的引用变量一旦初始化赋值后就不能再指向其它的对象，那么该引用变量指向的对象的内容可变吗？看下面这个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">final MyClass myClass = new MyClass();</span><br><span class="line">System.out.println(++myClass.i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyClass&#123;</span><br><span class="line">public int i = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码可以顺利通过编译并输出结果，输出结果为1。这说明引用变量被final修饰之后，虽然不能再指向其它对象，但它指向的对象的内容可以改变。</p><h3 id="final和static"><a href="#final和static" class="headerlink" title="final和static"></a>final和static</h3><p>很多时候会容易把static和final关键字混淆，static只用于成员变量用来表示只保存一份副本，而final的作用是保证变量不可变。看下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">MyClass myClass1 = new MyClass();</span><br><span class="line">MyClass myClass2 = new MyClass();</span><br><span class="line">System.out.println(myClass1.i);</span><br><span class="line">    System.out.println(myClass1.j);</span><br><span class="line">    System.out.println(myClass2.i);</span><br><span class="line">System.out.println(myClass2.j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyClass&#123;</span><br><span class="line">public final double i = Math.random();</span><br><span class="line">public static double j = Math.random();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行这段代码会发现，每次打印的两个j值是一样的，而i的值是不同的，这里就可以知道final和static的区别了。</p><h3 id="final参数"><a href="#final参数" class="headerlink" title="final参数"></a>final参数</h3><p>java允许在参数列表中以声明的方式将参数指明为final。这意味着你无法在方法中更改参数引用所指向的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Gizmo&#123;</span><br><span class="line">public void spin()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FinalArguments&#123;</span><br><span class="line">void with(final Gizmo g)&#123;</span><br><span class="line">// g = new Gizmo();   //非法的，因为g是final的</span><br><span class="line">&#125;</span><br><span class="line">void without(Gizmo g)&#123;</span><br><span class="line">g = new Gizmo();      //合法的，g不是final的</span><br><span class="line">g.spin();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;java的final关键字通常指“这是无法改变的”，使用到final的三种情况：变量、方法、类。&lt;/p&gt;
&lt;h2 id=&quot;final关键字的基本用法&quot;&gt;&lt;a href=&quot;#final关键字的基本用法&quot; class=&quot;headerlink&quot; title=&quot;final关键字的基
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
</feed>
